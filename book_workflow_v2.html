<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>ä¸€ç«™å¼ä¹¦ç±å¤„ç†å·¥ä½œæµ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      :root {
        color-scheme: light;
        font-family: "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
        background-color: #f8fafc;
        color: #0f172a;
      }

      /* å¯¼èˆªæ æ ·å¼ */
      .top-navbar {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 12px 20px;
        margin: -24px -24px 24px -24px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 0;
        z-index: 1000;
      }

      .nav-container {
        max-width: 1400px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 20px;
        flex-wrap: wrap;
      }

      .nav-brand {
        color: white;
        font-weight: 600;
        font-size: 18px;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .nav-brand:hover {
        opacity: 0.9;
      }

      .nav-links {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .nav-link {
        color: white;
        text-decoration: none;
        padding: 8px 14px;
        border-radius: 6px;
        font-size: 14px;
        transition: all 0.2s;
        white-space: nowrap;
      }

      .nav-link:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .nav-link.active {
        background: rgba(255, 255, 255, 0.25);
        font-weight: 500;
      }

      body {
        margin: 0;
        padding: 24px;
        max-width: 1400px;
        margin: 0 auto;
      }

      h1 {
        margin-top: 0;
        margin-bottom: 8px;
        font-size: 32px;
        font-weight: 600;
        color: #0f172a;
      }

      .subtitle {
        color: #64748b;
        font-size: 14px;
        margin-bottom: 32px;
      }

      .panel {
        background: #ffffff;
        border-radius: 16px;
        padding: 28px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        margin-bottom: 24px;
        border: 1px solid #e2e8f0;
      }

      .panel h2 {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 20px;
        font-weight: 600;
        color: #1e293b;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: flex-start;
      }

      .control-group {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        flex: 1;
        min-width: 300px;
      }

      .control-group.primary {
        flex: 2;
        min-width: 400px;
      }

      input[type="file"] {
        flex: 1;
        min-width: 200px;
        padding: 10px 14px;
        border: 1.5px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
        background: #ffffff;
        transition: border-color 0.2s, box-shadow 0.2s;
      }

      input[type="file"]:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      input[type="password"],
      input[type="text"],
      input[type="number"] {
        flex: 1;
        min-width: 180px;
        padding: 10px 14px;
        border: 1.5px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
        background: #ffffff;
        transition: border-color 0.2s, box-shadow 0.2s;
      }

      input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        margin-right: 8px;
      }

      label.checkbox-label {
        display: flex;
        align-items: center;
        font-size: 14px;
        color: #1e293b;
        cursor: pointer;
        user-select: none;
      }

      input[type="password"]:focus,
      input[type="text"]:focus,
      input[type="number"]:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      select {
        padding: 10px 14px;
        border: 1.5px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
        background: #ffffff;
        transition: border-color 0.2s, box-shadow 0.2s;
      }

      select:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      textarea {
        width: 100%;
        padding: 12px;
        border: 1.5px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
        font-family: inherit;
        resize: vertical;
        min-height: 120px;
      }

      textarea:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      button {
        padding: 10px 20px;
        border-radius: 8px;
        border: none;
        background: #2563eb;
        color: white;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      button.secondary {
        background: #10b981;
      }

      button:disabled {
        background: #cbd5e1;
        color: #94a3b8;
        cursor: not-allowed;
        transform: none;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
      }

      button.secondary:hover:not(:disabled) {
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
      }

      button:active:not(:disabled) {
        transform: translateY(0);
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        border-radius: 12px;
        overflow: hidden;
        background: #ffffff;
      }

      thead {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      th {
        padding: 16px;
        text-align: left;
        font-weight: 600;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      td {
        padding: 16px;
        text-align: left;
        border-bottom: 1px solid #e2e8f0;
        vertical-align: top;
        font-size: 14px;
      }

      tbody tr {
        transition: background-color 0.15s ease;
      }

      tbody tr:hover {
        background: rgba(102, 126, 234, 0.05);
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      .status {
        margin-top: 16px;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        background: #f1f5f9;
        border-left: 4px solid #cbd5e1;
      }

      .status.info {
        background: #eff6ff;
        border-left-color: #3b82f6;
        color: #1e40af;
      }

      .status.success {
        background: #f0fdf4;
        border-left-color: #10b981;
        color: #065f46;
      }

      .status.error {
        background: #fef2f2;
        border-left-color: #ef4444;
        color: #991b1b;
      }

      .progress-wrapper {
        margin-bottom: 20px;
        display: none;
      }

      .progress-wrapper.active {
        display: block;
      }

      .progress-label {
        font-size: 14px;
        color: #475569;
        margin-bottom: 8px;
        font-weight: 500;
      }

      .progress-bar {
        width: 100%;
        height: 10px;
        border-radius: 999px;
        background: #e2e8f0;
        overflow: hidden;
        position: relative;
      }

      .progress-fill {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 0%;
        border-radius: 999px;
        background: linear-gradient(135deg, #4f46e5 0%, #14b8a6 100%);
        transition: width 0.3s ease;
      }

      .loading {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid rgba(0, 0, 0, 0.1);
        border-top-color: currentColor;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        margin-right: 8px;
        vertical-align: middle;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* æ­¥éª¤æ¡æ ·å¼ */
      .steps-bar {
        display: flex;
        background: #fff;
        border-radius: 12px;
        padding: 0;
        margin-bottom: 24px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        overflow: hidden;
      }

      .step-item {
        flex: 1;
        padding: 16px 12px;
        text-align: center;
        cursor: pointer;
        border-right: 1px solid #eee;
        transition: all 0.2s;
        background: #fff;
      }

      .step-item:last-child {
        border-right: none;
      }

      .step-item:hover {
        background: #f8f9fa;
      }

      .step-item.active {
        background: #6366f1;
        color: #fff;
      }

      .step-item.done {
        background: #10b981;
        color: #fff;
      }

      .step-num {
        font-size: 20px;
        font-weight: 700;
      }

      .step-name {
        font-size: 12px;
        margin-top: 4px;
      }

      .panel.hidden {
        display: none;
      }

      @media (max-width: 768px) {
        body {
          padding: 16px;
        }

        .panel {
          padding: 20px;
        }

        .control-group {
          min-width: 100%;
        }

        .control-group.primary {
          min-width: 100%;
        }

        table {
          font-size: 12px;
        }

        th,
        td {
          padding: 12px 8px;
        }

        button {
          font-size: 13px;
          padding: 8px 16px;
        }
      }

      dialog {
        border: none;
        border-radius: 16px;
        padding: 0;
        width: min(800px, 90vw);
        max-height: 85vh;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      }

      dialog h3 {
        margin: 0;
        padding: 24px 28px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        font-size: 20px;
        font-weight: 600;
        border-radius: 16px 16px 0 0;
      }

      dialog .modal-body {
        padding: 24px 28px;
        overflow-y: auto;
        max-height: calc(85vh - 140px);
        white-space: pre-wrap;
        line-height: 1.8;
        color: #334155;
        font-size: 14px;
      }

      dialog > div:last-child {
        padding: 20px 28px;
        background: #f8fafc;
        border-radius: 0 0 16px 16px;
        border-top: 1px solid #e2e8f0;
      }

      dialog::backdrop {
        background-color: rgba(15, 23, 42, 0.5);
        backdrop-filter: blur(4px);
      }

      /* å·¥ä½œæµ Tab æ ·å¼ */
      .workflow-tab {
        background: #fff;
      }
      .workflow-tab:hover {
        background: #f8fafc;
      }
      .workflow-tab.active {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }
      .workflow-tab.active div:last-child {
        color: rgba(255,255,255,0.8);
      }
    </style>
  </head>
  <body>
    <!-- å¯¼èˆªæ  -->
    <nav class="top-navbar">
      <div class="nav-container">
        <a href="/" class="nav-brand">ğŸ“š PDFè§£è¯»ç³»ç»Ÿ</a>
        <div class="nav-links">
          <a href="/" class="nav-link">ğŸ  é¦–é¡µ</a>
          <a href="/aigen_test_page.html" class="nav-link">âœ¨ ä¸ªæ€§åŒ–è§£è¯»</a>
          <a href="/book_workflow_v2.html" class="nav-link active">ğŸ“– ä¸€ç«™å¼å¤„ç†</a>
          <a href="/book_restructure_page.html" class="nav-link">ğŸ“š ä¹¦ç±é‡æ„</a>
          <a href="/parser_test_page.html" class="nav-link">ğŸ“„ æ–‡æ¡£è§£æ</a>
          <a href="/admin_books.html" class="nav-link">ğŸ“– ä¹¦ç±ç®¡ç†</a>
          <a href="/admin.html" class="nav-link">âš™ï¸ ç³»ç»Ÿç®¡ç†</a>
        </div>
      </div>
    </nav>

    <h1>ğŸ“š ä¸€ç«™å¼ä¹¦ç±å¤„ç†å·¥ä½œæµ</h1>
    <p class="subtitle">å·¥ä½œæµä¸€ï¼šä¹¦ç±é‡æ„ | å·¥ä½œæµäºŒï¼šä¹¦ç±è§£è¯»</p>

    <!-- å·¥ä½œæµåˆ‡æ¢ Tab -->
    <div class="workflow-tabs" style="display: flex; gap: 0; margin-bottom: 24px; background: #fff; border-radius: 12px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
      <div class="workflow-tab active" data-workflow="1" style="flex: 1; padding: 16px 20px; text-align: center; cursor: pointer; border-right: 1px solid #e2e8f0; transition: all 0.2s; font-weight: 600;">
        <div style="font-size: 24px; margin-bottom: 4px;">ğŸ“–</div>
        <div>å·¥ä½œæµä¸€ï¼šä¹¦ç±é‡æ„</div>
        <div style="font-size: 12px; color: #64748b; margin-top: 4px;">ä¸Šä¼  â†’ æ¸…æ´— â†’ è§£æ â†’ é‡æ„ â†’ ç”Ÿæˆæ–°ä¹¦</div>
      </div>
      <div class="workflow-tab" data-workflow="2" style="flex: 1; padding: 16px 20px; text-align: center; cursor: pointer; transition: all 0.2s; font-weight: 600;">
        <div style="font-size: 24px; margin-bottom: 4px;">ğŸ“</div>
        <div>å·¥ä½œæµäºŒï¼šä¹¦ç±è§£è¯»</div>
        <div style="font-size: 12px; color: #64748b; margin-top: 4px;">é€‰æ‹©ä¹¦ç± â†’ é€‰æ‹©ç« èŠ‚ â†’ ç”Ÿæˆè§£è¯»æ–‡ç« </div>
      </div>
    </div>

    <!-- ==================== å·¥ä½œæµä¸€ï¼šä¹¦ç±é‡æ„ ==================== -->
    <div id="workflow1" class="workflow-content">

    <!-- æ­¥éª¤æ¡ -->
    <div class="steps-bar">
      <div class="step-item active" data-step="1"><div class="step-num">1</div><div class="step-name">ä¸Šä¼ æ–‡ä»¶</div></div>
      <div class="step-item" data-step="2"><div class="step-num">2</div><div class="step-name">ç›®å½•æ¸…æ´—</div></div>
      <div class="step-item" data-step="3"><div class="step-num">3</div><div class="step-name">è§£æå…¥åº“</div></div>
      <div class="step-item" data-step="4"><div class="step-num">4</div><div class="step-name">é‡æ„ç›®å½•</div></div>
      <div class="step-item" data-step="5"><div class="step-num">5</div><div class="step-name">ç”Ÿæˆæ–°ä¹¦</div></div>
      <div class="step-item" data-step="6"><div class="step-num">6</div><div class="step-name">æ–°ä¹¦å…¥åº“</div></div>
    </div>

    <!-- æ­¥éª¤1: ä¸Šä¼ æ–‡ä»¶ -->
    <section id="panel1" class="panel">
      <h2>ğŸ“„ æ­¥éª¤1: ä¸Šä¼ æ–‡ä»¶</h2>
      <div class="controls">
        <div class="control-group primary">
          <input type="file" id="pdfFile" accept="application/pdf,application/epub+zip,.pdf,.epub" />
          <label class="checkbox-label">
            <input type="checkbox" id="translateBookCheckbox" />
            <span>æ˜¯å¦ç¿»è¯‘ä¹¦ç±ï¼ˆè‹±æ–‡ä¹¦ï¼‰</span>
          </label>
          <button id="loadFromDbButton" style="background: #8b5cf6;">ğŸ“š ä»æ•°æ®åº“åŠ è½½</button>
        </div>
      </div>
      <div class="status" id="status1"></div>
    </section>

    <!-- æ­¥éª¤2: ç›®å½•æ¸…æ´— -->
    <section id="panel2" class="panel hidden">
      <h2>ğŸ§¹ æ­¥éª¤2: ç›®å½•æ¸…æ´—</h2>
      <p style="color: #64748b; font-size: 14px; margin-bottom: 16px;">ä½¿ç”¨å¤§æ¨¡å‹è¿‡æ»¤å‰è¨€ã€é™„å½•ç­‰éæ­£æ–‡å†…å®¹ï¼Œä¿ç•™æ ¸å¿ƒç« èŠ‚</p>
      <div class="controls">
        <button id="cleanTocButton" disabled>å¼€å§‹ç›®å½•æ¸…æ´—</button>
      </div>
      <div class="status" id="status2"></div>
      <div id="tocPreview" style="display: none; margin-top: 16px; padding: 16px; background: #f8fafc; border-radius: 8px; max-height: 300px; overflow-y: auto;"></div>
    </section>

    <!-- æ­¥éª¤3: è§£æå…¥åº“ -->
    <section id="panel3" class="panel hidden">
      <h2>ğŸ“Š æ­¥éª¤3: è§£æå†…å®¹ä¸å…¥åº“</h2>
      <div class="controls" style="margin-bottom: 16px;">
        <button id="extractButton" disabled>è§£æç« èŠ‚å†…å®¹</button>
        <button id="translateAllButton" style="background: #10b981; display: none;">ğŸŒ ä¸€é”®ç¿»è¯‘å…¨éƒ¨</button>
        <button id="ingestButton" class="secondary" disabled>åŸºæœ¬ä¿¡æ¯å…¥åº“</button>
      </div>
      <div id="progressWrapper" class="progress-wrapper">
        <div id="progressLabel" class="progress-label">å‡†å¤‡ä¸­...</div>
        <div class="progress-bar">
          <div id="progressFill" class="progress-fill"></div>
        </div>
      </div>
      <div class="status" id="status3"></div>
      <div id="chapterTable" style="display: none; margin-top: 16px;">
        <table>
          <thead>
            <tr>
              <th>ç›®å½•æ ‡é¢˜</th>
              <th>å†…å®¹</th>
              <th>å­—æ•°</th>
              <th>ç¿»è¯‘</th>
              <th>æ¦‚è¿°</th>
            </tr>
          </thead>
          <tbody id="resultsBody">
            <tr><td colspan="5" style="text-align: center; color: #94a3b8; padding: 40px;">ç­‰å¾…è§£æç»“æœ...</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- æ­¥éª¤4: é‡æ„ç›®å½• -->
    <section id="panel4" class="panel hidden">
      <h2>ğŸ”„ æ­¥éª¤4: é‡æ„ç›®å½•</h2>
      <div class="controls" style="margin-bottom: 16px;">
        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #475569;">
          <span>åˆ†å‰²å­—æ•°ä¸Šé™ï¼š</span>
          <input type="number" id="restructureMaxWords" value="5000" min="1000" max="20000" step="500" style="width: 100px;" />
          <span style="color: #94a3b8;">å­—/æ®µ</span>
        </label>
      </div>
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #475569;">ç›®å½•é‡æ„æç¤ºè¯</label>
        <textarea id="restructurePrompt" rows="10"></textarea>
      </div>
      <div class="controls">
        <button id="restructureTocButton" disabled>ğŸ”„ å¼€å§‹é‡æ„ç›®å½•</button>
      </div>
      <div class="status" id="status4"></div>
      <details id="thinkingDetails" style="display: none; margin-top: 16px;">
        <summary style="cursor: pointer; padding: 8px 12px; background: #fef3c7; border-radius: 6px; font-weight: 500; color: #92400e;">ğŸ’­ æŸ¥çœ‹æ€è€ƒè¿‡ç¨‹</summary>
        <div id="thinkingContent" style="margin-top: 8px; padding: 12px; background: #fffbeb; border-radius: 6px; font-size: 13px; line-height: 1.7; color: #78350f; max-height: 300px; overflow-y: auto; white-space: pre-wrap;"></div>
      </details>
      <div id="newTocPreview" style="display: none; margin-top: 16px; padding: 16px; background: #f8fafc; border-radius: 8px; white-space: pre-wrap; line-height: 1.8; font-size: 14px;"></div>
    </section>

    <!-- æ­¥éª¤5: ç”Ÿæˆæ–°ä¹¦ -->
    <section id="panel5" class="panel hidden">
      <h2>ğŸ“– æ­¥éª¤5: ç”Ÿæˆæ–°ä¹¦</h2>
      <div class="controls" style="margin-bottom: 16px;">
        <select id="partSelector" style="min-width: 200px;">
          <option value="">é€‰æ‹©Partæµ‹è¯•...</option>
        </select>
        <button id="testPartButton" style="background: #f59e0b;" disabled>ğŸ”„ æµ‹è¯•è¯¥Part</button>
        <button id="generateNewBookButton" class="secondary" disabled>ğŸ“– ç”Ÿæˆæ•´æœ¬æ–°ä¹¦</button>
      </div>
      <div id="progressWrapper5" class="progress-wrapper">
        <div id="progressLabel5" class="progress-label">å‡†å¤‡ä¸­...</div>
        <div class="progress-bar">
          <div id="progressFill5" class="progress-fill"></div>
        </div>
      </div>
      <div class="status" id="status5"></div>
      <div id="singlePartResult" style="display: none; margin-top: 16px; padding: 16px; background: #fffbeb; border: 1px solid #fcd34d; border-radius: 8px;"></div>
      <div id="newBookPreview" style="display: none; margin-top: 16px;">
        <div style="display: grid; grid-template-columns: 280px 1fr; gap: 16px;">
          <div style="background: #f8fafc; border-radius: 8px; padding: 16px;">
            <h3 style="margin: 0 0 12px; font-size: 14px; color: #475569;">ğŸ“‘ æ–°ä¹¦ç›®å½•</h3>
            <div id="newBookTocTree" style="max-height: 400px; overflow-y: auto;"></div>
          </div>
          <div style="background: #fff; border-radius: 8px; padding: 16px; border: 1px solid #e2e8f0;">
            <h3 id="previewTitle" style="margin: 0 0 12px; font-size: 14px; color: #475569;">ğŸ“„ é€‰æ‹©å·¦ä¾§ç« èŠ‚æŸ¥çœ‹å†…å®¹</h3>
            <div id="newBookContentPreview" style="min-height: 300px; max-height: 400px; overflow-y: auto; line-height: 1.8; color: #334155; font-size: 14px;">
              <p style="color: #94a3b8; text-align: center; margin-top: 100px;">ç‚¹å‡»å·¦ä¾§ç›®å½•æŸ¥çœ‹å†…å®¹</p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- æ­¥éª¤6: æ–°ä¹¦å…¥åº“ -->
    <section id="panel6" class="panel hidden">
      <h2>ğŸ’¾ æ­¥éª¤6: æ–°ä¹¦å…¥åº“</h2>
      <div class="controls">
        <label style="display: flex; align-items: center; gap: 8px; flex: 1;">
          <span style="white-space: nowrap;">æ–°ä¹¦åç§°ï¼š</span>
          <input type="text" id="newBookName" style="flex: 1;" placeholder="è¾“å…¥æ–°ä¹¦åç§°..." />
        </label>
        <button id="saveNewBookButton" class="secondary" disabled>ğŸ’¾ ä¿å­˜åˆ°æ•°æ®åº“</button>
      </div>
      <div id="newBookSummary" style="margin-top: 12px; font-size: 13px; color: #64748b;"></div>
      <div class="status" id="status6"></div>
    </section>

    </div><!-- å·¥ä½œæµä¸€ç»“æŸ -->

    <!-- ==================== å·¥ä½œæµäºŒï¼šä¹¦ç±è§£è¯» ==================== -->
    <div id="workflow2" class="workflow-content" style="display: none;">
      
      <!-- æ­¥éª¤æ¡ -->
      <div class="steps-bar">
        <div class="step-item active" data-step="w2-1"><div class="step-num">1</div><div class="step-name">é€‰æ‹©ä¹¦ç±</div></div>
        <div class="step-item" data-step="w2-2"><div class="step-num">2</div><div class="step-name">é€‰æ‹©ç« èŠ‚</div></div>
        <div class="step-item" data-step="w2-3"><div class="step-num">3</div><div class="step-name">ç”Ÿæˆè§£è¯»</div></div>
      </div>

      <!-- æ­¥éª¤1: é€‰æ‹©ä¹¦ç± -->
      <section id="w2Panel1" class="panel">
        <h2>ğŸ“š æ­¥éª¤1: é€‰æ‹©ä¹¦ç±</h2>
        <div class="controls">
          <div class="control-group primary">
            <select id="w2BookSelect" style="flex: 1; min-width: 300px;">
              <option value="">è¯·é€‰æ‹©å·²å…¥åº“çš„ä¹¦ç±...</option>
            </select>
            <button id="w2RefreshBooks" style="background: #64748b;">ğŸ”„ åˆ·æ–°åˆ—è¡¨</button>
          </div>
        </div>
        <div id="w2BookInfo" style="display: none; margin-top: 16px; padding: 16px; background: #f0fdf4; border-radius: 8px; border: 1px solid #bbf7d0;">
          <div style="font-weight: 600; color: #166534;" id="w2BookTitle"></div>
          <div style="font-size: 13px; color: #15803d; margin-top: 4px;" id="w2BookStats"></div>
        </div>
        <div class="status" id="w2Status1"></div>
      </section>

      <!-- æ­¥éª¤2: é€‰æ‹©ç« èŠ‚ -->
      <section id="w2Panel2" class="panel hidden">
        <h2>ğŸ“‘ æ­¥éª¤2: é€‰æ‹©ç« èŠ‚</h2>
        <p style="color: #64748b; font-size: 14px; margin-bottom: 16px;">é€‰æ‹©è¦è§£è¯»çš„ç« èŠ‚ï¼Œæˆ–é€‰æ‹©"å…¨éƒ¨ç« èŠ‚"ç”Ÿæˆæ•´æœ¬ä¹¦çš„è§£è¯»</p>
        <div class="controls" style="margin-bottom: 16px;">
          <select id="w2ChapterSelect" style="flex: 1; min-width: 400px;">
            <option value="">è¯·é€‰æ‹©ç« èŠ‚...</option>
            <option value="all">ğŸ“– å…¨éƒ¨ç« èŠ‚ï¼ˆç”Ÿæˆæ•´æœ¬ä¹¦è§£è¯»ï¼‰</option>
          </select>
        </div>
        <div id="w2ChapterInfo" style="display: none; margin-top: 16px; padding: 16px; background: #eff6ff; border-radius: 8px; border: 1px solid #bfdbfe;">
          <div style="font-weight: 600; color: #1e40af;" id="w2ChapterTitle"></div>
          <div style="font-size: 13px; color: #1d4ed8; margin-top: 4px;" id="w2ChapterStats"></div>
        </div>
        <div class="status" id="w2Status2"></div>
      </section>

      <!-- æ­¥éª¤3: ç”Ÿæˆè§£è¯» -->
      <section id="w2Panel3" class="panel hidden">
        <h2>ğŸ“ æ­¥éª¤3: ç”Ÿæˆè§£è¯»æ–‡ç« </h2>
        
        <!-- æç¤ºè¯é…ç½®ï¼ˆå¯æŠ˜å ï¼‰ -->
        <details style="margin-bottom: 16px;">
          <summary style="cursor: pointer; font-weight: 600; font-size: 14px; color: #475569; padding: 8px 0;">ğŸ”§ æç¤ºè¯é…ç½®ï¼ˆç‚¹å‡»å±•å¼€ï¼‰</summary>
          <div style="margin-top: 12px;">
            <textarea id="w2PromptText" rows="15" style="width: 100%; font-size: 13px;"></textarea>
            <div style="display: flex; gap: 12px; margin-top: 12px;">
              <button class="secondary" onclick="w2ResetPrompt()" style="padding: 8px 16px; font-size: 13px;">ğŸ”„ é‡ç½®ä¸ºé»˜è®¤</button>
              <button class="secondary" onclick="w2SavePrompt()" style="padding: 8px 16px; font-size: 13px;">ğŸ’¾ ä¿å­˜æç¤ºè¯</button>
            </div>
          </div>
        </details>

        <div class="controls">
          <button id="w2GenerateBtn" disabled>ğŸš€ ç”Ÿæˆè§£è¯»æ–‡ç« </button>
          <button id="w2GenerateAllBtn" style="background: #8b5cf6; display: none;" disabled>ğŸ“š ç”Ÿæˆå…¨ä¹¦è§£è¯»</button>
          <button id="w2CopyBtn" class="secondary" style="display: none;">ğŸ“‹ å¤åˆ¶ç»“æœ</button>
        </div>
        
        <div id="w2ProgressWrapper" class="progress-wrapper" style="display: none;">
          <div id="w2ProgressLabel" class="progress-label">å‡†å¤‡ä¸­...</div>
          <div class="progress-bar">
            <div id="w2ProgressFill" class="progress-fill"></div>
          </div>
        </div>
        
        <div class="status" id="w2Status3"></div>
        
        <!-- æ€è€ƒè¿‡ç¨‹ -->
        <details id="w2ThinkingBox" style="display: none; margin-top: 16px;">
          <summary style="cursor: pointer; padding: 8px 12px; background: #fef3c7; border-radius: 6px; font-weight: 500; color: #92400e;">ğŸ’­ æŸ¥çœ‹æ€è€ƒè¿‡ç¨‹</summary>
          <div id="w2ThinkingContent" style="margin-top: 8px; padding: 12px; background: #fffbeb; border-radius: 6px; font-size: 13px; line-height: 1.7; color: #78350f; max-height: 300px; overflow-y: auto; white-space: pre-wrap;"></div>
        </details>
        
        <!-- è§£è¯»ç»“æœ -->
        <div id="w2ResultContainer" style="display: none; margin-top: 20px; padding: 24px; background: #f8fafc; border-radius: 12px; border: 1px solid #e2e8f0;">
          <div id="w2ResultContent" style="line-height: 1.8; color: #1e293b; font-size: 15px;"></div>
          <div id="w2ResultWordCount" style="font-size: 13px; color: #64748b; margin-top: 12px;"></div>
        </div>
        
        <!-- å…¨ä¹¦è§£è¯»ç»“æœåˆ—è¡¨ -->
        <div id="w2AllResultsContainer" style="display: none; margin-top: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <h3 style="margin: 0; font-size: 16px; color: #1e293b;">ğŸ“š å…¨ä¹¦è§£è¯»ç»“æœ</h3>
            <button id="w2CopyAllBtn" class="secondary" style="padding: 8px 16px; font-size: 13px;">ğŸ“‹ å¤åˆ¶å…¨éƒ¨</button>
          </div>
          <div id="w2AllResultsList"></div>
        </div>
      </section>

    </div><!-- å·¥ä½œæµäºŒç»“æŸ -->

    <!-- ç›®å½•å¯¹æ¯”å¼¹çª— -->
    <dialog id="tocCompareDialog" style="max-width: 90vw; width: 1200px; padding: 0; border-radius: 12px;">
      <div style="padding: 24px; border-bottom: 1px solid #e2e8f0;">
        <h3 style="margin: 0; font-size: 20px; font-weight: 600; background: none; padding: 0; color: #1e293b;">ç›®å½•æ¸…æ´—å¯¹æ¯”</h3>
      </div>
      <div style="padding: 24px; display: grid; grid-template-columns: 1fr 1fr; gap: 24px; max-height: 70vh; overflow-y: auto;">
        <div>
          <h4 style="margin: 0 0 16px 0; color: #64748b; font-size: 14px; font-weight: 600;">æ¸…æ´—å‰ (å…± <span id="rawCount">0</span> é¡¹)</h4>
          <div id="rawTocList" style="background: #f8fafc; padding: 16px; border-radius: 8px; font-size: 13px; line-height: 1.8; max-height: 60vh; overflow-y: auto;"></div>
        </div>
        <div>
          <h4 style="margin: 0 0 16px 0; color: #10b981; font-size: 14px; font-weight: 600;">æ¸…æ´—å (å…± <span id="cleanedCount">0</span> é¡¹)</h4>
          <div id="cleanedTocList" style="background: #f0fdf4; padding: 16px; border-radius: 8px; font-size: 13px; line-height: 1.8; max-height: 60vh; overflow-y: auto;"></div>
        </div>
      </div>
      <div style="padding: 16px 24px; border-top: 1px solid #e2e8f0; text-align: right;">
        <button id="closeTocDialog">å…³é—­</button>
      </div>
    </dialog>

    <!-- å†…å®¹æŸ¥çœ‹å¼¹çª— -->
    <dialog id="contentDialog">
      <h3 id="dialogTitle"></h3>
      <div class="modal-body" id="dialogContent"></div>
      <div style="text-align: right">
        <button id="closeDialog">å…³é—­</button>
      </div>
    </dialog>

    <!-- ä»æ•°æ®åº“åŠ è½½ä¹¦ç±å¼¹çª— -->
    <dialog id="loadBookDialog" style="max-width: 90vw; width: 1000px; padding: 0; border-radius: 12px; max-height: 90vh;">
      <div style="padding: 24px; border-bottom: 1px solid #e2e8f0; background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%); color: white; border-radius: 12px 12px 0 0;">
        <h3 style="margin: 0; font-size: 20px; font-weight: 600; background: none; padding: 0;">ğŸ“š ä»æ•°æ®åº“åŠ è½½ä¹¦ç±</h3>
        <p style="margin: 8px 0 0 0; font-size: 14px; opacity: 0.9;">é€‰æ‹©å·²è§£æçš„ä¹¦ç±ï¼Œç›´æ¥åŠ è½½å…¶ç›®å½•å’Œå†…å®¹</p>
      </div>
      <div style="padding: 24px; max-height: calc(90vh - 140px); overflow-y: auto;">
        <div style="margin-bottom: 16px;">
          <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 12px;">
            <input type="text" id="bookSearchInput" placeholder="æœç´¢ä¹¦ç±åç§°..." style="flex: 1;" />
            <button id="refreshBooksBtn" style="background: #64748b;">åˆ·æ–°</button>
          </div>
        </div>
        <div id="booksList" style="display: grid; gap: 12px;">
          <div style="text-align: center; padding: 40px; color: #94a3b8;"><span class="loading"></span> åŠ è½½ä¸­...</div>
        </div>
      </div>
      <div style="padding: 16px 24px; border-top: 1px solid #e2e8f0; text-align: right; background: #f8fafc; border-radius: 0 0 12px 12px;">
        <button id="closeLoadBookDialog">å…³é—­</button>
      </div>
    </dialog>


    <script>
      // ===== é»˜è®¤çš„ç›®å½•é‡æ„æç¤ºè¯ï¼ˆå®Œæ•´ç‰ˆï¼Œä» book_restructure_page.html å¤åˆ¶ï¼‰ =====
      const DEFAULT_RESTRUCTURE_PROMPT = `ä½ æ˜¯ä¸€ä½è¶…å‰å®³çš„æ·±åº¦é˜…è¯»è¾¾äººï¼Œç‰¹åˆ«æ“…é•¿ç»“æ„åŒ–åˆ†æã€‚ç°åœ¨è¦æ ¹æ®å…¨ä¹¦çš„"ç« èŠ‚æ ‡é¢˜ + æ‘˜è¦"ï¼Œç»™è¿™æœ¬ä¹¦æ­å»ºä¸€ä¸ªè¶…æ¸…æ™°çš„é«˜å±‚è¯­ä¹‰ç»“æ„ã€‚

ä¸‹é¢æœ‰ä¸€ç»„ç« èŠ‚ä¿¡æ¯ï¼Œæ¯ä¸€é¡¹éƒ½åŒ…å«ç« èŠ‚ç¼–å·ã€ç« èŠ‚æ ‡é¢˜å’Œç« èŠ‚æ‘˜è¦ï¼š
<chapters>
{chapters}
</chapters>

ä½ çš„ä»»åŠ¡æ˜¯ï¼Œä¾æ®è¿™äº›æ ‡é¢˜å’Œæ‘˜è¦ï¼ŒæŠŠæ•´æœ¬ä¹¦é‡æ–°åˆ†æˆåˆé€‚æ•°é‡çš„é«˜å±‚ä¸»é¢˜ï¼ˆPartï¼‰ã€‚

å…·ä½“è¦æ±‚å¦‚ä¸‹ï¼š

1. å¥½å¥½åƒé€å…¨ä¹¦å†…å®¹ï¼š
   - è®¤çœŸè¯»å®Œæ‰€æœ‰ç« èŠ‚çš„æ ‡é¢˜å’Œæ‘˜è¦ã€‚
   - æ‰¾å‡ºå…¨ä¹¦çš„æ ¸å¿ƒæ€æƒ³ã€ä¸»è¦è¯é¢˜ï¼Œè¿˜æœ‰ä½œè€…æƒ³è¦è§£å†³çš„é—®é¢˜ã€‚

2. æŒ‰åŸä¹¦é¡ºåºåˆ’åˆ†"å¤§ä¸»é¢˜ / ç¯‡ç« ï¼ˆPartï¼‰"ï¼š
   - **å…³é”®çº¦æŸï¼šæ¯ä¸ª Part å¿…é¡»åŒ…å«è¿ç»­çš„ç« èŠ‚ï¼Œä¸¥ç¦è·³è·ƒå¼åˆ†ç»„ã€‚** æ¯”å¦‚å¯ä»¥æ˜¯"1ã€2ã€3ã€4"æˆ–"5ã€6ã€7"ï¼Œç»å¯¹ä¸èƒ½å‡ºç°"2ã€6ã€10ã€14"è¿™ç§ä¸è¿ç»­çš„æƒ…å†µã€‚
   - ä½ çš„ä»»åŠ¡æ˜¯æ‰¾åˆ°åˆé€‚çš„"åˆ‡åˆ†ç‚¹"ï¼ŒæŠŠå…¨ä¹¦æŒ‰é¡ºåºåˆ‡æˆå‡ ä¸ªå¤§å—ã€‚
   - æ ¹æ®å†…å®¹å®é™…æƒ…å†µå†³å®š Part æ•°é‡ï¼Œå¯èƒ½æ˜¯ 2 ä¸ªã€3 ä¸ªã€5 ä¸ªç”šè‡³æ›´å¤šã€‚
   - æ¯ä¸ªä¸»é¢˜é‡Œé¢çš„å†…å®¹å¾—ç´§å¯†ç›¸å…³ã€‚
   - ä¸»é¢˜åç§°è¦é€šä¿—æ˜“æ‡‚ï¼Œç”ŸåŠ¨æœ‰è¶£ï¼Œè®©äººçœ‹äº†å°±æƒ³è¯»ï¼Œåˆ«æé‚£ç§å¾ˆå­¦æœ¯çš„é£æ ¼ã€‚

3. åˆ—å‡ºæ¯ä¸ªä¸»é¢˜åŒ…å«çš„ç« èŠ‚ç¼–å·ï¼ˆå¿…é¡»è¿ç»­ä¸”æŒ‰é¡ºåºï¼‰ï¼Œå†ç»™æ¯ä¸ªä¸»é¢˜å†™ä¸€ä¸ªæ–°çš„æ‘˜è¦ã€‚

è¾“å‡ºæ ¼å¼å¿…é¡»æ˜¯ä¸‹é¢è¿™æ ·ï¼ˆPart æ•°é‡æ ¹æ®å®é™…å†…å®¹å†³å®šï¼‰ï¼š

Part 1ï¼š{ä¸»é¢˜åç§°}
    è¦†ç›–ç« èŠ‚ï¼š{è¿ç»­çš„ç« èŠ‚ç¼–å·åˆ—è¡¨ï¼Œå¦‚ 1ã€2ã€3ã€4}
    æ‘˜è¦ï¼š{å¯¹è¯¥ä¸»é¢˜å†…å®¹çš„ç®€è¦æ¦‚æ‹¬}

Part 2ï¼š{ä¸»é¢˜åç§°}
    è¦†ç›–ç« èŠ‚ï¼š{è¿ç»­çš„ç« èŠ‚ç¼–å·åˆ—è¡¨ï¼Œå¦‚ 5ã€6ã€7ã€8}
    æ‘˜è¦ï¼š{å¯¹è¯¥ä¸»é¢˜å†…å®¹çš„ç®€è¦æ¦‚æ‹¬}

...ï¼ˆæ ¹æ®å®é™…å†…å®¹ç»§ç»­ï¼Œä¸é™åˆ¶ Part æ•°é‡ï¼‰

åˆ«åšå¤šä½™è§£é‡Šï¼Œä¹Ÿåˆ«é‡å¤ç»™æ‘˜è¦ï¼Œåªè¦ç»™å‡º"ä¸»é¢˜åç§° + åŒ…å«ç« èŠ‚ + ä¸»é¢˜æ‘˜è¦"å°±è¡Œã€‚`;

      // ===== å·¥ä½œæµäºŒï¼šä¹¦ç±è§£è¯»çš„é»˜è®¤æç¤ºè¯ =====
      const DEFAULT_INTERPRETATION_PROMPT = `# Role: é¡¶çº§çŸ¥è¯†"è§£å‰–å¸ˆ"ä¸ç•…é”€ä¸“æ ä½œå®¶

## Profile
ä½ ä¸ä»…ä»…æ˜¯ä¸€ä¸ªå¤è¿°è€…ï¼Œä½ æ˜¯ä¸€ä½ç»“åˆäº†**"è´¹æ›¼çš„é™ç»´æ‰“å‡»èƒ½åŠ›"**ã€**"çº¦ç‘Ÿå¤«Â·èˆ’æ ¼æ›¼çš„æ»‘æ¢¯æ–‡æ¡ˆæŠ€å·§"**ä»¥åŠ**"é©¬å°”ç§‘å§†Â·æ ¼æ‹‰å¾·å¨å°”çš„å™äº‹æ´å¯ŸåŠ›"**çš„é¡¶å°–å†…å®¹è§£å‰–å¸ˆã€‚ä½ çš„ä½¿å‘½æ˜¯å°†ä»»ä½•ä¸€æ®µè¾“å…¥çš„ä¹¦ç±ç« èŠ‚æ–‡æœ¬ï¼ˆæ— è®ºå¤šä¹ˆæ¯ç‡¥æˆ–æ·±å¥¥ï¼‰ï¼Œé‡é“¸ä¸ºä¸€ç¯‡è®©äºº"é¢…å†…é«˜æ½®"çš„æ·±åº¦è§£è¯»æ–‡ç« ï¼Œéœ€è¦†ç›–ä¹¦ç±ç« èŠ‚çš„æ ¸å¿ƒè®ºç‚¹ã€å…³é”®æ¡ˆä¾‹ã€åº•å±‚é€»è¾‘åŠå®è·µä»·å€¼å››ä¸ªæ ¸å¿ƒç»´åº¦ï¼Œæ·±åº¦ä½“ç°åœ¨å¯¹åº•å±‚é€»è¾‘çš„é€šä¿—åŒ–æ‹†è§£å’Œå®è·µä»·å€¼çš„åœºæ™¯åŒ–å»¶ä¼¸ç›®æ ‡å—ä¼—ä¸º25-40å²çš„èŒåœºäººå£«ä¸ç»ˆèº«å­¦ä¹ è€…ï¼Œä»–ä»¬å…·å¤‡åŸºç¡€è®¤çŸ¥èƒ½åŠ›ï¼Œè¿½æ±‚çŸ¥è¯†çš„å®ç”¨æ€§ä¸æ€æƒ³çš„å¯å‘æ€§ï¼Œåå¥½è½»æ¾æ˜“æ‡‚åˆä¸å¤±æ·±åº¦çš„å†…å®¹

## Core Philosophy (æ ¸å¿ƒå¿ƒæ³•)
1.  **è¯»è€…æœ¬ä½ï¼š** è¯»è€…å¾ˆå¿™ï¼Œä¹Ÿå¾ˆæ‡’ã€‚å¦‚æœç¬¬ä¸€å¥è¯ä¸èƒ½ç”µåˆ°ä»–ï¼Œä½ å°±å¤±è´¥äº†ã€‚
2.  **æ»‘æ¢¯ç†è®ºï¼š** æ¯ä¸€æ®µçš„ç»“å°¾å¿…é¡»æ˜¯ä¸‹ä¸€æ®µçš„è¯±é¥µã€‚
3.  **çŸ¥è¯†ç»“æ™¶ï¼š** é€šä¿—ä¸ä»£è¡¨è‚¤æµ…ã€‚å¿…é¡»ç”¨æœ€æµ…æ˜¾çš„è¯­è¨€ï¼Œè®²é€æœ€ç¡¬æ ¸çš„é€»è¾‘ï¼ˆUnderlying Logicï¼‰ã€‚

## Critical Workflow (æ‰§è¡Œæµç¨‹)

### Step 0: æ·±åº¦æ€è€ƒä¸è§£æ„ (éšå½¢æ­¥éª¤)
**åœ¨æ­£å¼å†™ä½œå‰ï¼Œä½ å¿…é¡»å…ˆåœ¨"å¤§è„‘"ä¸­å®Œæˆä»¥ä¸‹å¤„ç†ï¼š**
1.  **å¯»æ‰¾å†²çª (Find the Conflict)ï¼š** åŸæ–‡æ¨ç¿»äº†å“ªä¸ªå¸¸è¯†ï¼Ÿè§£å†³äº†å“ªä¸ªç—›ç‚¹ï¼Ÿæˆ–è€…æ­ç¤ºäº†ä»€ä¹ˆæ®‹é…·çœŸç›¸ï¼Ÿè¿™æ˜¯ä½ çš„åˆ‡å…¥ç‚¹ã€‚
2.  **æç‚¼éšå–» (Design the Metaphor)ï¼š** æ‰¾åˆ°ä¸€ä¸ªè´¯ç©¿å…¨æ–‡çš„å¼ºåŠ›æ¯”å–»ï¼ˆå¦‚ï¼šå°†"åšå¼ˆè®º"æ¯”ä½œ"èƒ†å°é¬¼æ¸¸æˆ"ï¼Œå°†"å¤åˆ©"æ¯”ä½œ"æ»šé›ªçƒ"ï¼‰ã€‚
3.  **è§„åˆ’è·¯æ ‡ (Structure the Arc)ï¼š** ç¡®å®š 3-4 ä¸ªæ ¸å¿ƒè½¬æŠ˜ç‚¹ï¼Œå¹¶ä¸ºå®ƒä»¬è®¾è®¡åƒ"ç”µå½±ç‰‡å"ä¸€æ ·å¸å¼•äººçš„å°æ ‡é¢˜ã€‚

### Step 1: æ’°å†™æ­£æ–‡ (æ‰§è¡Œæ ‡å‡†)

#### 1. å¼ºåŠ›é’©å­ (The Hook) â€”â€” æ‹’ç»åºŸè¯
* **ç¦æ­¢ï¼š** ç»å¯¹ç¦æ­¢ä½¿ç”¨"è¿™ç¯‡æ–‡ç« è®²äº†..."ã€"ä½œè€…æ˜¯..."è¿™ç§æ‘˜è¦å¼å¼€å¤´ã€‚
* **å¿…é¡»ï¼š** ç›´æ¥ä»ä¸€ä¸ª**åç›´è§‰çš„åœºæ™¯ã€ä¸€ä¸ªæ‰å¿ƒçš„é—®é¢˜ã€æˆ–ä¸€ä¸ªé¢ è¦†æ€§çš„ç»“è®º**åˆ‡å…¥ã€‚
* *ç¤ºä¾‹ï¼š* "ä½ ä»¥ä¸ºåŠªåŠ›å°±èƒ½æˆåŠŸï¼Ÿæ•°æ®å‘Šè¯‰ä½ ï¼Œè¿™å¯èƒ½æ˜¯ä¸ªéª—å±€ã€‚"

#### 2. æ­å»ºæ»‘æ¢¯ (The Slide) â€”â€” é€»è¾‘æµ
* ä½¿ç”¨**"æ‚¬å¿µè¿æ¥è¯" (Bucket Brigades)** æ¥ç²˜åˆæ®µè½ï¼Œå¦‚ï¼š"ä½†è¿™è¿˜ä¸æ˜¯æœ€ç³Ÿç³•çš„..."ã€"äº‹å®çœŸç›¸è®©äººå¤§åƒä¸€æƒŠ..."ã€"ä½ å¯èƒ½ä¼šé—®..."ã€‚
* ä¿æŒ**å¯¹è¯æ„Ÿ**ï¼Œå°±åƒä½ åœ¨å’–å•¡é¦†é‡Œå¯¹ç€æœ‹å‹è¯´è¯ã€‚å¤šç”¨"ä½ "ã€"æˆ‘ä»¬"ã€‚

#### 3. æ ¸å¿ƒäº¤ä»˜ (The Meat) â€”â€” é™ç»´æ‰“å‡»
* **ç²¾å‡†é™ç»´ï¼š** é‡åˆ°ä¸“ä¸šæœ¯è¯­ï¼Œå¿…é¡»ç«‹åˆ»ç´§è·Ÿä¸€ä¸ª**ç”Ÿæ´»åŒ–ç±»æ¯”**ã€‚
* **è§†è§‰é«˜äº®ï¼š** ä¹Ÿå°±æ˜¯**åŠ ç²—**ã€‚è¯·å°†æ–‡ä¸­çš„**"é‡‘å¥"ï¼ˆèƒ½å¼•å‘è¯»è€…å¼ºçƒˆå…±é¸£çš„å‡ç»ƒè¡¨è¾¾ï¼‰ã€"æ ¸å¿ƒç»“è®º"ï¼ˆåŸæ–‡çš„å…³é”®ä¸»å¼ æˆ–æœ€ç»ˆè§‚ç‚¹ï¼‰æˆ–"è½¬æŠ˜ç‚¹"ï¼ˆé€»è¾‘æ¨å¯¼ä¸­æ”¹å˜è®¤çŸ¥æ–¹å‘çš„å…³é”®èŠ‚ç‚¹ï¼‰**ç”¨MarkdownåŠ ç²—ï¼Œæ–¹ä¾¿è¯»è€…æ‰«è¯»ã€‚ä½†ä¸è¦æ»¡ç¯‡åŠ ç²—ï¼Œæ¯ç¯‡è§£è¯»çš„åŠ ç²—å†…å®¹ä¸è¶…è¿‡8å¤„
* **ä¸¥è°¨å†…æ ¸ï¼š** æ‰€æœ‰çš„æ¼”ç»å¿…é¡»ä¸¥æ ¼æœåŠ¡äºåŸä½œè€…çš„é€»è¾‘ï¼Œä¸¥ç¦ä¸ºäº†æ•…äº‹æ€§è€Œç¯¡æ”¹åŸæ„ã€‚

#### 4. æ€§æ„Ÿçš„å°æ ‡é¢˜ (Subheadings)
* **ç¦æ­¢ï¼š** æ•™ç§‘ä¹¦å¼çš„æ ‡é¢˜ï¼ˆå¦‚"æ¦‚å¿µå®šä¹‰"ã€"æ¡ˆä¾‹åˆ†æ"ï¼‰ã€‚
* **å¿…é¡»ï¼š** å¸¦æœ‰æ‚¬å¿µã€å†²çªæˆ–ç”»é¢æ„Ÿçš„å°æ ‡é¢˜ã€‚
* *ç¤ºä¾‹ï¼š* ç”¨"ä¸ºä»€ä¹ˆ'è‡ªæ–­åè·¯'æ‰æ˜¯é¡¶çº§æ™ºæ…§ï¼Ÿ"ä»£æ›¿"èƒŒæ°´ä¸€æˆ˜çš„ç­–ç•¥åˆ†æ"ã€‚

#### 5. å¼ºåŠ›æ”¶å°¾ (The Landing)
* ç”¨ä¸€å¥æœ‰åŠ›çš„é‡‘å¥æ”¶å°¾ï¼Œæˆ–è€…ç»™è¯»è€…ä¸€ä¸ªå³åˆ»å¯ç”¨çš„è¡ŒåŠ¨å»ºè®®ï¼ˆCall to Actionï¼‰ã€‚

---

## Input Data
<ä¹¦ç±ç« èŠ‚>
{BOOK_CHAPTER}
</ä¹¦ç±ç« èŠ‚>

## Output Generation
è¯·æ ¹æ®ä¸Šè¿°ç­–ç•¥ï¼Œåœ¨<è§£è¯»>æ ‡ç­¾å†…è¾“å‡ºè§£è¯»å†…å®¹ã€‚è§£è¯»æ–‡ç« éœ€æ§åˆ¶åœ¨2000 - 2500å­—ã€‚

**æ³¨æ„ï¼š** ä¸éœ€è¦è¾“å‡º Step 0 çš„æ€è€ƒè¿‡ç¨‹ï¼Œç›´æ¥è¾“å‡ºæœ€ç»ˆæ‰“ç£¨å¥½çš„ã€å¯ä»¥ç›´æ¥å‘å¸ƒçš„æ·±åº¦è§£è¯»æ–‡ç« ã€‚

<è§£è¯»>`;

      // ===== å…¨å±€çŠ¶æ€ =====
      let currentStep = 1;
      let currentWorkflow = 1; // å½“å‰å·¥ä½œæµï¼š1=ä¹¦ç±é‡æ„ï¼Œ2=ä¹¦ç±è§£è¯»
      let parsedEntries = [];
      let currentFilename = "";
      let cleanedTocData = null;
      let currentFileType = null;
      let restructuredTocContent = null;
      let parsedParts = [];
      let newBookStructure = null;
      let restructureChapters = [];
      let allBooks = [];

      // ===== DOM å…ƒç´ å¼•ç”¨ =====
      const pdfFile = document.getElementById("pdfFile");
      const translateBookCheckbox = document.getElementById("translateBookCheckbox");
      const loadFromDbButton = document.getElementById("loadFromDbButton");
      const cleanTocButton = document.getElementById("cleanTocButton");
      const extractButton = document.getElementById("extractButton");
      const translateAllButton = document.getElementById("translateAllButton");
      const ingestButton = document.getElementById("ingestButton");
      const restructureTocButton = document.getElementById("restructureTocButton");
      const restructurePrompt = document.getElementById("restructurePrompt");
      const restructureMaxWords = document.getElementById("restructureMaxWords");
      const partSelector = document.getElementById("partSelector");
      const testPartButton = document.getElementById("testPartButton");
      const generateNewBookButton = document.getElementById("generateNewBookButton");
      const saveNewBookButton = document.getElementById("saveNewBookButton");
      const newBookName = document.getElementById("newBookName");
      const resultsBody = document.getElementById("resultsBody");
      const progressWrapper = document.getElementById("progressWrapper");
      const progressLabel = document.getElementById("progressLabel");
      const progressFill = document.getElementById("progressFill");
      const progressWrapper5 = document.getElementById("progressWrapper5");
      const progressLabel5 = document.getElementById("progressLabel5");
      const progressFill5 = document.getElementById("progressFill5");
      const tocCompareDialog = document.getElementById("tocCompareDialog");
      const contentDialog = document.getElementById("contentDialog");
      const loadBookDialog = document.getElementById("loadBookDialog");

      // ===== å·¥å…·å‡½æ•° =====
      function escapeHtml(text) {
        if (text === null || text === undefined) return '';
        if (typeof text !== 'string') text = String(text);
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      function renderStatus(elementId, message, type = "info") {
        const element = document.getElementById(elementId);
        if (!element) return;
        element.className = `status ${type}`;
        const loading = type === "info" && (message.includes("æ­£åœ¨") || message.includes("è¯·ç¨å€™")) 
          ? '<span class="loading"></span>' 
          : '';
        element.innerHTML = loading + message;
        element.style.display = 'block';
      }

      function calculateWordCount(text) {
        if (!text) return 0;
        return text.replace(/\s+/g, "").length;
      }

      function showProgress(wrapper, fill, label, total = 0, labelText = "æ­£åœ¨å‡†å¤‡...") {
        if (!wrapper) return;
        wrapper.classList.add("active");
        wrapper.style.display = "block";
        updateProgress(wrapper, fill, label, 0, total, labelText);
      }

      function updateProgress(wrapper, fill, labelEl, completed, total, labelText) {
        if (!wrapper) return;
        if (!wrapper.classList.contains("active")) wrapper.classList.add("active");
        if (wrapper.style.display !== "block") wrapper.style.display = "block";
        const percent = total > 0 ? Math.min(100, Math.max(0, Math.round((completed / total) * 100))) : 0;
        if (fill) fill.style.width = `${percent}%`;
        if (labelEl) labelEl.textContent = labelText || `è¿›åº¦ï¼š${completed}/${total} (${percent}%)`;
      }

      function hideProgress(wrapper, fill) {
        if (!wrapper) return;
        wrapper.classList.remove("active");
        wrapper.style.display = "none";
        if (fill) fill.style.width = "0%";
      }

      // ===== æ­¥éª¤å¯¼èˆª =====
      function goToStep(n) {
        document.querySelectorAll('.step-item').forEach((s, i) => {
          s.classList.remove('active', 'done');
          if (i + 1 < n) s.classList.add('done');
          else if (i + 1 === n) s.classList.add('active');
        });
        for (let i = 1; i <= 6; i++) {
          const panel = document.getElementById(`panel${i}`);
          if (panel) panel.classList.toggle('hidden', i > n);
        }
        currentStep = n;
      }

      document.querySelectorAll('.step-item').forEach(s => {
        s.addEventListener('click', () => {
          const n = parseInt(s.dataset.step);
          if (n <= currentStep) goToStep(n);
        });
      });

      // ===== ç”Ÿæˆç›®å½•ä¸æ‘˜è¦æ–‡æœ¬ï¼ˆä» book_restructure_page.html å¤åˆ¶ï¼‰ =====
      function generateTocSummaryText(entries) {
        if (!entries || entries.length === 0) return "";
        let text = "";
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          const chapterNumber = i + 1;
          const chapterTitle = entry.title_zh || entry.title || `ç¬¬${chapterNumber}ç« `;
          const chapterSummary = entry.summary || "";
          text += `${chapterNumber}. ${chapterTitle}`;
          if (chapterSummary) text += `\n${chapterSummary}`;
          text += "\n\n";
        }
        return text.trim();
      }


      // ===== æ·±åº¦æ€è€ƒæ¨¡å‹è°ƒç”¨ï¼ˆä» book_restructure_page.html å¤åˆ¶ï¼‰ =====
      async function interpretWithDeepThinking(content, prompt, options = {}) {
        const {
          model = 'doubao-seed-1-6-251015',
          temperature = 0.3,
          max_tokens = 16000,
          timeout = 300000,
          replacements = {}
        } = options;

        let finalPrompt = prompt;
        const safeReplacements = (replacements && typeof replacements === 'object' && !Array.isArray(replacements)) ? replacements : {};
        if (content && !safeReplacements.chapter_fulltext) {
          safeReplacements.chapter_fulltext = content;
        }
        if (safeReplacements && typeof safeReplacements === 'object' && !Array.isArray(safeReplacements)) {
          const keys = Object.keys(safeReplacements);
          for (let i = 0; i < keys.length; i++) {
            const placeholder = keys[i];
            const value = safeReplacements[placeholder];
            if (value !== undefined && value !== null) {
              const regex = new RegExp(`{${placeholder}}`, 'g');
              finalPrompt = finalPrompt.replace(regex, String(value));
            }
          }
        }

        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          let response;
          try {
            response = await fetch("/api/test/doubao-thinking", {
              method: "POST",
              headers: { "Content-Type": "application/json", "Accept": "application/json" },
              body: JSON.stringify({
                prompt: finalPrompt,
                temperature: temperature,
                max_tokens: max_tokens,
                model: model,
              }),
              signal: controller.signal,
            });
          } catch (fetchError) {
            clearTimeout(timeoutId);
            if (fetchError.name === "AbortError") {
              throw new Error("è¯·æ±‚è¶…æ—¶ï¼ˆè¶…è¿‡5åˆ†é’Ÿï¼‰ï¼Œè¯·ç¨åé‡è¯•");
            }
            const errorMsg = fetchError.message || String(fetchError);
            if (errorMsg.includes("Failed to fetch") || errorMsg.includes("NetworkError")) {
              throw new Error("æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦æ­£åœ¨è¿è¡Œ");
            }
            throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${errorMsg}`);
          }
          clearTimeout(timeoutId);

          if (!response.ok) {
            let errorMessage = "ç”Ÿæˆå¤±è´¥";
            try {
              const errorText = await response.text();
              try {
                const errorData = JSON.parse(errorText);
                errorMessage = errorData.error || errorMessage;
              } catch (e) {
                errorMessage = errorText || errorMessage;
              }
            } catch (e) {
              errorMessage = `HTTP ${response.status}: ${response.statusText}`;
            }
            throw new Error(errorMessage);
          }

          let data;
          try {
            data = await response.json();
          } catch (jsonError) {
            throw new Error(`æœåŠ¡å™¨å“åº”æ ¼å¼é”™è¯¯: ${jsonError.message}`);
          }
          
          if (!data || typeof data !== 'object' || Array.isArray(data)) {
            throw new Error('åç«¯è¿”å›çš„æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
          }
          
          return {
            reasoning_content: (data.reasoning_content && typeof data.reasoning_content === 'string') ? data.reasoning_content : null,
            content: (data.content && typeof data.content === 'string') ? data.content : null,
            success: true
          };

        } catch (error) {
          let errorMessage = "è§£è¯»å¤±è´¥";
          if (error.name === "AbortError" || error.name === "TimeoutError") {
            errorMessage = "è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•";
          } else if (error.message) {
            errorMessage = error.message;
          }
          throw new Error(errorMessage);
        }
      }

      // ===== è§£ææ–°ç›®å½•ç»“æ„ï¼ˆä» book_restructure_page.html å¤åˆ¶ï¼‰ =====
      function parseNewTocStructure(tocText) {
        if (!tocText) {
          console.warn("parseNewTocStructure: tocText ä¸ºç©º");
          return [];
        }
        
        console.log("å¼€å§‹è§£æç›®å½•ç»“æ„ï¼ŒåŸå§‹æ–‡æœ¬é•¿åº¦:", tocText.length);
        
        const parts = [];
        const lines = tocText.split('\n');
        let currentPart = null;
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const trimmedLine = line.trim();
          
          if (!trimmedLine) continue;
          
          const partMatch = trimmedLine.match(/^(?:Part|PART|éƒ¨åˆ†|ç¬¬\s*)?\s*(\d+)[ï¼š:ï¼š]\s*(.+)$/i);
          if (partMatch) {
            if (currentPart) {
              parts.push(currentPart);
            }
            const partNumber = parseInt(partMatch[1]);
            const title = partMatch[2].trim();
            currentPart = {
              partNumber: partNumber,
              title: title,
              coveredChapters: [],
              summary: ""
            };
            continue;
          }
          
          if (currentPart) {
            const coveredMatch = trimmedLine.match(/è¦†ç›–ç« èŠ‚[ï¼š:ï¼š]\s*(.+)$/);
            if (coveredMatch) {
              const chapterText = coveredMatch[1].trim();
              const chapterNumbers = chapterText
                .split(/[ï¼Œ,ã€\s\t]+/)
                .map(n => {
                  const cleaned = n.replace(/[ï¼ˆï¼‰()\[\]ã€ã€‘""''ã€,ï¼Œ]/g, '').trim();
                  const num = parseInt(cleaned);
                  return isNaN(num) ? null : num;
                })
                .filter(n => n !== null && n > 0);
              
              currentPart.coveredChapters = chapterNumbers;
              continue;
            }
          }
          
          if (currentPart) {
            const summaryMatch = trimmedLine.match(/æ‘˜è¦[ï¼š:ï¼š]\s*(.+)$/);
            if (summaryMatch) {
              currentPart.summary = summaryMatch[1].trim();
              continue;
            }
          }
        }
        
        if (currentPart) {
          parts.push(currentPart);
        }
        
        const sortedParts = parts.sort((a, b) => a.partNumber - b.partNumber);
        console.log(`è§£æå®Œæˆï¼Œå…±æ‰¾åˆ° ${sortedParts.length} ä¸ªéƒ¨åˆ†`);
        sortedParts.forEach(p => {
          console.log(`Part ${p.partNumber}: ${p.title}, è¦†ç›–ç« èŠ‚: [${p.coveredChapters.join(', ')}]`);
        });
        return sortedParts;
      }

      // ===== ç« èŠ‚åˆ†å‰²å‡½æ•°ï¼ˆä» book_restructure_page.html å¤åˆ¶ï¼‰ =====
      async function splitChapterContent(title, content, maxWordCount) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 600000);
        
        try {
          const response = await fetch("/api/restructure/split-chapter", {
            method: "POST",
            headers: { "Content-Type": "application/json", "Accept": "application/json" },
            body: JSON.stringify({
              title: title || "æœªå‘½åç« èŠ‚",
              content: content.trim(),
              max_word_count: maxWordCount,
              word_count: 0
            }),
            signal: controller.signal,
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            let errorMessage = `åˆ†å‰²å¤±è´¥ (çŠ¶æ€ç : ${response.status})`;
            try {
              const errorText = await response.text();
              try {
                const errorData = JSON.parse(errorText);
                errorMessage = errorData.error || errorMessage;
              } catch (e) {
                errorMessage = errorText || errorMessage;
              }
            } catch (e) {}
            throw new Error(errorMessage);
          }
          
          let splitResult;
          try {
            splitResult = await response.json();
          } catch (jsonError) {
            throw new Error(`æœåŠ¡å™¨å“åº”æ ¼å¼é”™è¯¯: ${jsonError.message}`);
          }
          
          const segments = splitResult.segments || [];
          if (segments.length === 0) {
            throw new Error("åˆ†å‰²å¤±è´¥ï¼Œæœªç”Ÿæˆä»»ä½•ç‰‡æ®µ");
          }
          
          return segments.map((segment, index) => ({
            title: segment.title || `ç¬¬${index + 1}éƒ¨åˆ†`,
            content: segment.content || "",
            word_count: segment.word_count || 0
          }));
          
        } catch (fetchError) {
          clearTimeout(timeoutId);
          if (fetchError.name === "AbortError") {
            throw new Error("è¯·æ±‚è¶…æ—¶ï¼ˆè¶…è¿‡10åˆ†é’Ÿï¼‰ï¼Œè¯·ç¨åé‡è¯•");
          }
          const errorMsg = fetchError.message || String(fetchError);
          if (errorMsg.includes("Failed to fetch") || errorMsg.includes("NetworkError")) {
            throw new Error("æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨");
          }
          throw fetchError;
        }
      }


      // ===== æ­¥éª¤1: æ–‡ä»¶ä¸Šä¼  =====
      pdfFile.addEventListener("change", (e) => {
        if (e.target.files.length > 0) {
          currentFilename = e.target.files[0].name;
          renderStatus("status1", `å·²é€‰æ‹©æ–‡ä»¶: ${currentFilename}`, "success");
          cleanTocButton.disabled = false;
          goToStep(2);
        }
      });

      // ä»æ•°æ®åº“åŠ è½½ä¹¦ç±
      loadFromDbButton.addEventListener("click", async () => {
        loadBookDialog.showModal();
        await loadBooksFromDatabase();
      });

      document.getElementById("closeLoadBookDialog").addEventListener("click", () => loadBookDialog.close());
      document.getElementById("refreshBooksBtn").addEventListener("click", loadBooksFromDatabase);
      document.getElementById("bookSearchInput").addEventListener("input", (e) => filterBooks(e.target.value));

      async function loadBooksFromDatabase() {
        const booksList = document.getElementById("booksList");
        booksList.innerHTML = '<div style="text-align: center; padding: 40px; color: #94a3b8;"><span class="loading"></span> åŠ è½½ä¸­...</div>';
        
        try {
          const response = await fetch("/api/admin/books?page=1&per_page=100");
          const data = await response.json();
          if (data.error) throw new Error(data.error);
          allBooks = data.books || [];
          renderBooksList(allBooks);
        } catch (error) {
          booksList.innerHTML = `<div style="text-align: center; padding: 40px; color: #ef4444;">åŠ è½½å¤±è´¥: ${error.message}</div>`;
        }
      }

      function renderBooksList(books) {
        const booksList = document.getElementById("booksList");
        if (books.length === 0) {
          booksList.innerHTML = '<div style="text-align: center; padding: 40px; color: #94a3b8;">æš‚æ— ä¹¦ç±æ•°æ®</div>';
          return;
        }
        
        booksList.innerHTML = "";
        books.forEach((book) => {
          const bookCard = document.createElement("div");
          bookCard.style.cssText = "padding: 16px; border: 1px solid #e2e8f0; border-radius: 8px; background: #ffffff; cursor: pointer; transition: all 0.2s;";
          bookCard.onmouseover = () => { bookCard.style.borderColor = "#8b5cf6"; bookCard.style.boxShadow = "0 4px 12px rgba(139, 92, 246, 0.1)"; };
          bookCard.onmouseout = () => { bookCard.style.borderColor = "#e2e8f0"; bookCard.style.boxShadow = "none"; };
          bookCard.onclick = () => loadBookFromDatabase(book.id);
          
          bookCard.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
              <div style="font-weight: 600; font-size: 16px; color: #1e293b;">${escapeHtml(book.filename)}</div>
              <div style="font-size: 12px; color: #64748b;">ID: ${book.id}</div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px; font-size: 13px;">
              <div><div style="color: #64748b; margin-bottom: 4px;">ç« èŠ‚æ•°</div><div style="color: #1e293b; font-weight: 500;">${book.chapter_count} ç« </div></div>
              <div><div style="color: #64748b; margin-bottom: 4px;">æ€»å­—æ•°</div><div style="color: #1e293b; font-weight: 500;">${(book.total_word_count||0).toLocaleString()} å­—</div></div>
              <div><div style="color: #64748b; margin-bottom: 4px;">å…¥åº“æ—¶é—´</div><div style="color: #1e293b; font-weight: 500; font-size: 12px;">${new Date(book.created_at).toLocaleDateString("zh-CN")}</div></div>
            </div>
          `;
          booksList.appendChild(bookCard);
        });
      }

      function filterBooks(searchText) {
        if (!searchText.trim()) { renderBooksList(allBooks); return; }
        const filtered = allBooks.filter(book => book.filename.toLowerCase().includes(searchText.toLowerCase()));
        renderBooksList(filtered);
      }

      async function loadBookFromDatabase(bookId) {
        loadBookDialog.close();
        renderStatus("status1", "æ­£åœ¨ä»æ•°æ®åº“åŠ è½½ä¹¦ç±æ•°æ®...", "info");
        
        try {
          const response = await fetch(`/api/admin/books/${bookId}`);
          const data = await response.json();
          if (data.error) throw new Error(data.error);
          
          const book = data.book;
          const chapters = data.chapters || [];
          if (chapters.length === 0) throw new Error("è¯¥ä¹¦ç±æ²¡æœ‰ç« èŠ‚æ•°æ®");
          
          parsedEntries = chapters.map((chapter, index) => ({
            title: chapter.title || `ç¬¬ ${index + 1} ç« `,
            title_zh: chapter.title_zh || chapter.title || `ç¬¬ ${index + 1} ç« `,
            content: chapter.content || "",
            content_zh: chapter.content_zh || chapter.content || "",
            word_count: chapter.word_count || 0,
            summary: chapter.summary || ""
          }));
          
          restructureChapters = parsedEntries;
          currentFilename = book.filename;
          cleanedTocData = null;
          
          renderTable(parsedEntries);
          document.getElementById("chapterTable").style.display = "block";
          
          renderStatus("status1", `æˆåŠŸåŠ è½½ä¹¦ç±: ${book.filename} (${chapters.length} ç« )`, "success");
          restructureTocButton.disabled = false;
          goToStep(4);
        } catch (error) {
          renderStatus("status1", `åŠ è½½å¤±è´¥: ${error.message}`, "error");
        }
      }

      // ===== æ­¥éª¤2: ç›®å½•æ¸…æ´— =====
      cleanTocButton.addEventListener("click", async () => {
        if (!pdfFile.files.length) {
          renderStatus("status2", "è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶", "error");
          return;
        }

        const formData = new FormData();
        formData.append("file", pdfFile.files[0]);

        cleanTocButton.disabled = true;
        renderStatus("status2", "æ­£åœ¨æ¸…æ´—ç›®å½•ï¼Œè¯·ç¨å€™...", "info");

        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 300000);

          const response = await fetch("/api/parse/clean_toc", {
            method: "POST",
            body: formData,
            signal: controller.signal,
          });
          clearTimeout(timeoutId);

          const payload = await response.json();
          if (!response.ok) throw new Error(payload.error || `æ¸…æ´—ç›®å½•å¤±è´¥ (çŠ¶æ€ç : ${response.status})`);

          cleanedTocData = payload.cleaned_toc || [];
          currentFilename = payload.filename || "æœªçŸ¥æ–‡ä»¶";
          currentFileType = payload.file_type || null;
          
          renderStatus("status2", `ç›®å½•æ¸…æ´—å®Œæˆï¼Œä¿ç•™ ${cleanedTocData.length} ä¸ªç« èŠ‚`, "success");
          renderTocCompare(payload.raw_toc || [], payload.cleaned_toc || []);
          extractButton.disabled = false;
          goToStep(3);
        } catch (error) {
          renderStatus("status2", error.message, "error");
          cleanedTocData = null;
          extractButton.disabled = true;
        } finally {
          cleanTocButton.disabled = false;
        }
      });

      function renderTocCompare(rawToc, cleanedToc) {
        document.getElementById("rawCount").textContent = rawToc.length;
        document.getElementById("cleanedCount").textContent = cleanedToc.length;

        const rawTocList = document.getElementById("rawTocList");
        rawTocList.innerHTML = "";
        rawToc.forEach((item) => {
          const div = document.createElement("div");
          div.style.paddingLeft = `${(item.level - 1) * 20}px`;
          div.style.marginBottom = "4px";
          div.textContent = `${item.title} (ç¬¬${item.page}é¡µ)`;
          rawTocList.appendChild(div);
        });

        const cleanedTocList = document.getElementById("cleanedTocList");
        cleanedTocList.innerHTML = "";
        cleanedToc.forEach((item) => {
          const div = document.createElement("div");
          div.style.paddingLeft = `${(item.level - 1) * 20}px`;
          div.style.marginBottom = "4px";
          div.textContent = `${item.title} (ç¬¬${item.page}é¡µ)`;
          cleanedTocList.appendChild(div);
        });

        tocCompareDialog.showModal();
      }

      document.getElementById("closeTocDialog").addEventListener("click", () => tocCompareDialog.close());


      // ===== æ­¥éª¤3: è§£æå†…å®¹ä¸å…¥åº“ =====
      extractButton.addEventListener("click", async () => {
        if (!pdfFile.files.length) {
          renderStatus("status3", "è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶", "error");
          return;
        }

        if (!cleanedTocData || cleanedTocData.length === 0) {
          renderStatus("status3", "è¯·å…ˆå®Œæˆæ­¥éª¤2ï¼šç›®å½•æ¸…æ´—", "error");
          return;
        }

        extractButton.disabled = true;
        renderStatus("status3", "æ­£åœ¨æå–å†…å®¹å¹¶ç»Ÿè®¡ï¼Œè¯·ç¨å€™...", "info");

        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 300000);

          const formDataWithJson = new FormData();
          formDataWithJson.append("file", pdfFile.files[0]);
          formDataWithJson.append("cleaned_toc", JSON.stringify(cleanedTocData));
          if (currentFileType) formDataWithJson.append("file_type", currentFileType);

          const response = await fetch("/api/parse/extract", {
            method: "POST",
            body: formDataWithJson,
            signal: controller.signal,
          });
          clearTimeout(timeoutId);

          const payload = await response.json();
          if (!response.ok) throw new Error(payload.error || `æå–å†…å®¹å¤±è´¥ (çŠ¶æ€ç : ${response.status})`);

          parsedEntries = payload.entries || [];
          currentFilename = payload.filename || currentFilename;
          restructureChapters = parsedEntries;
          
          renderTable(parsedEntries);
          document.getElementById("chapterTable").style.display = "block";
          
          // æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨ç¿»è¯‘
          if (translateBookCheckbox && translateBookCheckbox.checked) {
            renderStatus("status3", `å†…å®¹æå–å®Œæˆï¼Œå…± ${parsedEntries.length} ç« ã€‚å¼€å§‹è‡ªåŠ¨ç¿»è¯‘...`, "info");
            await autoTranslateAll();
          } else {
            renderStatus("status3", `å†…å®¹æå–å®Œæˆï¼Œå…± ${parsedEntries.length} ç« `, "success");
          }
          
          ingestButton.disabled = parsedEntries.length === 0;
        } catch (error) {
          renderStatus("status3", error.message, "error");
          parsedEntries = [];
        } finally {
          extractButton.disabled = false;
        }
      });

      function renderTable(entries) {
        if (!entries || entries.length === 0) {
          resultsBody.innerHTML = `<tr><td colspan="5" style="text-align: center; color: #94a3b8; padding: 40px;">æœªè¯†åˆ«åˆ°æœ‰æ•ˆç›®å½•ã€‚</td></tr>`;
          ingestButton.disabled = true;
          return;
        }

        resultsBody.innerHTML = "";
        ingestButton.disabled = false;
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºä¸€é”®ç¿»è¯‘æŒ‰é’®
        const shouldTranslate = translateBookCheckbox && translateBookCheckbox.checked;
        const hasUntranslated = entries.some(e => {
          const hasTranslation = e.title_zh && e.content_zh && e.title_zh !== e.title && e.content_zh !== e.content;
          return !hasTranslation && e.title;
        });
        translateAllButton.style.display = (shouldTranslate && hasUntranslated) ? "inline-block" : "none";
        
        for (let index = 0; index < entries.length; index++) {
          const entry = entries[index];
          const row = document.createElement("tr");
          const displayTitle = entry.title_zh || entry.title;

          const titleCell = document.createElement("td");
          titleCell.textContent = displayTitle;
          if (entry.title_zh && entry.title_zh !== entry.title) {
            titleCell.title = `åŸæ–‡: ${entry.title}`;
            titleCell.style.color = "#2563eb";
          }

          const contentCell = document.createElement("td");
          const viewButton = document.createElement("button");
          viewButton.textContent = "æŸ¥çœ‹å†…å®¹";
          viewButton.style.cssText = "font-size: 13px; padding: 6px 12px;";
          viewButton.addEventListener("click", () => {
            const displayContent = entry.content_zh || entry.content || "(æš‚æ— æ­£æ–‡å†…å®¹)";
            document.getElementById("dialogTitle").textContent = displayTitle;
            document.getElementById("dialogContent").textContent = displayContent;
            contentDialog.showModal();
          });
          contentCell.appendChild(viewButton);

          const countCell = document.createElement("td");
          const count = entry.word_count || 0;
          countCell.innerHTML = `<span style="font-weight: 500; color: #475569;">${count.toLocaleString()}</span> <span style="color: #94a3b8; font-size: 12px;">å­—</span>`;

          const translateCell = document.createElement("td");
          const hasTranslation = entry.title_zh && entry.content_zh && entry.title_zh !== entry.title && entry.content_zh !== entry.content;
          const shouldTranslate = translateBookCheckbox && translateBookCheckbox.checked;
          
          if (hasTranslation) {
            translateCell.innerHTML = '<span style="color: #10b981; font-size: 12px;">âœ“ å·²ç¿»è¯‘</span>';
          } else if (shouldTranslate && entry.title) {
            // å¼€å…³æ‰“å¼€ï¼Œæ˜¾ç¤ºç¿»è¯‘æŒ‰é’®
            const translateButton = document.createElement("button");
            translateButton.textContent = "ğŸŒ ç¿»è¯‘";
            translateButton.style.cssText = "font-size: 13px; padding: 6px 12px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer;";
            translateButton.addEventListener("click", async () => {
              translateButton.disabled = true;
              translateButton.textContent = "ç¿»è¯‘ä¸­...";
              renderStatus("status3", `æ­£åœ¨ç¿»è¯‘ç« èŠ‚: ${entry.title}...`, "info");
              
              try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 600000);
                
                const response = await fetch("/api/translate/chapter", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ title: entry.title, content: entry.content || "" }),
                  signal: controller.signal,
                });
                clearTimeout(timeoutId);

                if (!response.ok) {
                  const errorData = await response.json().catch(() => ({}));
                  throw new Error(errorData.error || `ç¿»è¯‘å¤±è´¥ (çŠ¶æ€ç : ${response.status})`);
                }

                const payload = await response.json();
                entry.title_zh = payload.title_zh || entry.title_zh;
                entry.content_zh = payload.content_zh || entry.content_zh;
                if (payload.summary) entry.summary = payload.summary;
                // é‡æ–°è®¡ç®—ä¸­æ–‡å­—æ•°
                if (entry.content_zh) {
                  entry.word_count = entry.content_zh.replace(/\s+/g, "").length;
                }
                
                // åŒæ­¥æ›´æ–° restructureChapters
                restructureChapters = parsedEntries;
                renderTable(parsedEntries);
                renderStatus("status3", `ç« èŠ‚ç¿»è¯‘å®Œæˆ: ${payload.title_zh || entry.title}`, "success");
              } catch (error) {
                translateButton.disabled = false;
                translateButton.textContent = "ğŸŒ ç¿»è¯‘";
                renderStatus("status3", `ç¿»è¯‘å¤±è´¥: ${error.message}`, "error");
              }
            });
            translateCell.appendChild(translateButton);
          } else {
            translateCell.innerHTML = '<span style="color: #94a3b8;">â€”</span>';
          }

          const summaryCell = document.createElement("td");
          if (entry.summary) {
            const summaryButton = document.createElement("button");
            summaryButton.textContent = "æŸ¥çœ‹æ¦‚è¿°";
            summaryButton.style.cssText = "font-size: 13px; padding: 6px 12px;";
            summaryButton.addEventListener("click", () => {
              document.getElementById("dialogTitle").textContent = `${displayTitle} - æ¦‚è¿°`;
              document.getElementById("dialogContent").textContent = entry.summary || "(æš‚æ— æ¦‚è¿°)";
              contentDialog.showModal();
            });
            summaryCell.appendChild(summaryButton);
          } else {
            summaryCell.innerHTML = '<span style="color: #94a3b8;">â€”</span>';
          }

          row.appendChild(titleCell);
          row.appendChild(contentCell);
          row.appendChild(countCell);
          row.appendChild(translateCell);
          row.appendChild(summaryCell);
          resultsBody.appendChild(row);
        }
      }

      document.getElementById("closeDialog").addEventListener("click", () => contentDialog.close());

      // ç¿»è¯‘é”ï¼Œé˜²æ­¢é‡å¤æ‰§è¡Œ
      let isTranslating = false;

      // è‡ªåŠ¨ç¿»è¯‘å…¨éƒ¨ç« èŠ‚çš„å‡½æ•°ï¼ˆå¹¶å‘ç‰ˆæœ¬ï¼‰
      async function autoTranslateAll() {
        // é˜²æ­¢é‡å¤æ‰§è¡Œ
        if (isTranslating) {
          console.log("ç¿»è¯‘æ­£åœ¨è¿›è¡Œä¸­ï¼Œå¿½ç•¥é‡å¤è¯·æ±‚");
          return { success: false, message: "ç¿»è¯‘æ­£åœ¨è¿›è¡Œä¸­" };
        }
        
        if (!parsedEntries.length) {
          return { success: false, message: "æ²¡æœ‰å¯ç¿»è¯‘çš„ç« èŠ‚" };
        }

        // æ‰¾å‡ºæœªç¿»è¯‘çš„ç« èŠ‚
        const untranslatedIndices = [];
        for (let i = 0; i < parsedEntries.length; i++) {
          const entry = parsedEntries[i];
          const hasTranslation = entry.title_zh && entry.content_zh && 
                                 entry.title_zh !== entry.title && entry.content_zh !== entry.content;
          if (!hasTranslation && entry.title) {
            untranslatedIndices.push(i);
          }
        }

        if (untranslatedIndices.length === 0) {
          renderStatus("status3", "æ‰€æœ‰ç« èŠ‚éƒ½å·²ç¿»è¯‘", "success");
          return { success: true, message: "æ‰€æœ‰ç« èŠ‚éƒ½å·²ç¿»è¯‘" };
        }

        // è®¾ç½®ç¿»è¯‘é”
        isTranslating = true;
        
        translateAllButton.disabled = true;
        translateAllButton.style.display = "inline-block";
        const originalText = translateAllButton.textContent;
        
        const total = untranslatedIndices.length;
        let completed = 0;
        let successCount = 0;
        let failCount = 0;
        
        // æœ€å¤§å¹¶å‘æ•°ï¼ˆæµ‹è¯•è¡¨æ˜ 10-15 ä¸ªå¹¶å‘éƒ½èƒ½æ­£å¸¸å·¥ä½œï¼‰
        const MAX_CONCURRENCY = 10;
        
        showProgress(progressWrapper, progressFill, progressLabel, total, `å¼€å§‹ç¿»è¯‘ (æœ€å¤š${MAX_CONCURRENCY}ä¸ªå¹¶å‘)...`);

        // ä½¿ç”¨å·¥ä½œæ± æ¨¡å¼ï¼šå§‹ç»ˆä¿æŒæœ€å¤§å¹¶å‘ï¼Œä¸€ä¸ªå®Œæˆç«‹å³è¡¥å……ä¸‹ä¸€ä¸ª
        let currentIndex = 0;  // ä¸‹ä¸€ä¸ªè¦å¤„ç†çš„ä»»åŠ¡ç´¢å¼•
        let activeCount = 0;   // å½“å‰æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡æ•°
        const activeChapters = new Set();  // æ­£åœ¨ç¿»è¯‘çš„ç« èŠ‚ç´¢å¼•
        
        // æ›´æ–°è¿›åº¦æ˜¾ç¤ºï¼ˆåŒ…å«æ­£åœ¨ç¿»è¯‘çš„ç« èŠ‚ï¼‰
        function updateTranslateProgress() {
          const activeList = Array.from(activeChapters).map(i => i + 1).sort((a, b) => a - b);
          const activeText = activeList.length > 0 ? `æ­£åœ¨ç¿»è¯‘: ç¬¬ ${activeList.join(', ')} ç« ` : '';
          updateProgress(progressWrapper, progressFill, progressLabel, completed, total, 
            `å·²å®Œæˆ ${completed}/${total} ç« ï¼ˆæˆåŠŸ ${successCount}ï¼Œå¤±è´¥ ${failCount}ï¼‰${activeText ? '\n' + activeText : ''}`);
        }
        
        // ç¿»è¯‘å•ä¸ªç« èŠ‚çš„å‡½æ•°
        async function translateOne(idx) {
          const entry = parsedEntries[idx];
          activeChapters.add(idx);
          updateTranslateProgress();
          
          try {
            const response = await fetch("/api/translate/chapter", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: entry.title, content: entry.content || "" }),
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));
              throw new Error(errorData.error || `ç¿»è¯‘å¤±è´¥`);
            }

            const payload = await response.json();
            entry.title_zh = payload.title_zh || entry.title_zh;
            entry.content_zh = payload.content_zh || entry.content_zh;
            if (payload.summary) entry.summary = payload.summary;
            // é‡æ–°è®¡ç®—ä¸­æ–‡å­—æ•°
            if (entry.content_zh) {
              entry.word_count = entry.content_zh.replace(/\s+/g, "").length;
            }
            successCount++;
          } catch (error) {
            console.error(`ç¿»è¯‘ç« èŠ‚ ${idx + 1} å¤±è´¥:`, error);
            failCount++;
          } finally {
            activeChapters.delete(idx);
            completed++;
            translateAllButton.textContent = `ç¿»è¯‘ä¸­ ${completed}/${total}`;
            updateTranslateProgress();
          }
        }

        // å·¥ä½œæ± æ‰§è¡Œå™¨ï¼šå§‹ç»ˆä¿æŒæœ€å¤§å¹¶å‘æ•°
        await new Promise((resolve) => {
          function startNext() {
            // å¦‚æœè¿˜æœ‰ä»»åŠ¡ä¸”æœªè¾¾åˆ°æœ€å¤§å¹¶å‘ï¼Œå¯åŠ¨æ–°ä»»åŠ¡
            while (currentIndex < untranslatedIndices.length && activeCount < MAX_CONCURRENCY) {
              const idx = untranslatedIndices[currentIndex];
              currentIndex++;
              activeCount++;
              
              translateOne(idx).finally(() => {
                activeCount--;
                // ä»»åŠ¡å®Œæˆåï¼Œå°è¯•å¯åŠ¨ä¸‹ä¸€ä¸ªæˆ–æ£€æŸ¥æ˜¯å¦å…¨éƒ¨å®Œæˆ
                if (currentIndex < untranslatedIndices.length) {
                  startNext();
                } else if (activeCount === 0) {
                  resolve();
                }
              });
            }
            // å¦‚æœæ²¡æœ‰æ›´å¤šä»»åŠ¡ä¸”æ²¡æœ‰æ´»è·ƒä»»åŠ¡ï¼Œå®Œæˆ
            if (currentIndex >= untranslatedIndices.length && activeCount === 0) {
              resolve();
            }
          }
          startNext();
        });

        // é‡Šæ”¾ç¿»è¯‘é”
        isTranslating = false;

        // æ›´æ–°æ•°æ®å’ŒUI
        restructureChapters = parsedEntries;
        renderTable(parsedEntries);
        hideProgress(progressWrapper, progressFill);
        translateAllButton.textContent = originalText;
        translateAllButton.disabled = false;

        if (failCount === 0) {
          renderStatus("status3", `âœ… æ‰¹é‡ç¿»è¯‘å®Œæˆï¼æˆåŠŸç¿»è¯‘ ${successCount} ç« `, "success");
        } else {
          renderStatus("status3", `æ‰¹é‡ç¿»è¯‘å®Œæˆï¼šæˆåŠŸ ${successCount} ç« ï¼Œå¤±è´¥ ${failCount} ç« `, "info");
        }
        
        return { success: true, successCount, failCount };
      }

      // ä¸€é”®ç¿»è¯‘å…¨éƒ¨æŒ‰é’®
      translateAllButton.addEventListener("click", async () => {
        await autoTranslateAll();
      });

      // å…¥åº“æŒ‰é’®
      ingestButton.addEventListener("click", async () => {
        if (!parsedEntries.length) {
          renderStatus("status3", "è¯·å…ˆå®Œæˆè§£æ", "error");
          return;
        }

        ingestButton.disabled = true;
        renderStatus("status3", "æ­£åœ¨ç”Ÿæˆç« èŠ‚æ¦‚è¿°å¹¶å…¥åº“ï¼Œè¯·ç¨å€™...", "info");

        const totalChapters = parsedEntries.length;
        showProgress(progressWrapper, progressFill, progressLabel, totalChapters, "æ­£åœ¨å‡†å¤‡å…¥åº“ä»»åŠ¡...");

        try {
          const totalWordCount = parsedEntries.reduce((sum, entry) => {
            const wordCount = Number(entry.word_count);
            if (!Number.isNaN(wordCount) && wordCount > 0) return sum + wordCount;
            const content = entry.content || "";
            return sum + content.replace(/\s+/g, "").length;
          }, 0);

          const startResp = await fetch("/api/parse/ingest/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              filename: currentFilename,
              chapter_count: totalChapters,
              total_word_count: totalWordCount,
            }),
          });

          const startRaw = await startResp.text();
          let startPayload = {};
          if (startRaw.trim()) {
            try { startPayload = JSON.parse(startRaw.trim()); } catch (e) { throw new Error(`å…¥åº“åˆå§‹åŒ–å“åº”æ ¼å¼é”™è¯¯`); }
          }
          if (!startResp.ok) throw new Error(startPayload.error || `å…¥åº“åˆå§‹åŒ–å¤±è´¥`);

          const bookId = startPayload.book_id;
          if (bookId === undefined || bookId === null) throw new Error("å…¥åº“åˆå§‹åŒ–å¤±è´¥ï¼šæœªè¿”å› book_id");

          for (let index = 0; index < totalChapters; index++) {
            const entry = parsedEntries[index];
            const displayTitle = entry.title_zh || entry.title || `ç¬¬ ${index + 1} ç« `;
            updateProgress(progressWrapper, progressFill, progressLabel, index, totalChapters, `æ­£åœ¨å¤„ç†ç¬¬ ${index + 1}/${totalChapters} ç« ï¼š${displayTitle}`);

            const chapterResp = await fetch("/api/parse/ingest/chapter", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ book_id: bookId, entry, index }),
            });

            const chapterRaw = await chapterResp.text();
            let chapterPayload = {};
            if (chapterRaw.trim()) {
              try { chapterPayload = JSON.parse(chapterRaw.trim()); } catch (e) { throw new Error(`ç¬¬ ${index + 1} ç« å“åº”æ ¼å¼é”™è¯¯`); }
            }
            if (!chapterResp.ok) throw new Error(chapterPayload.error || `ç« èŠ‚ ${index + 1} å…¥åº“å¤±è´¥`);

            const processedEntry = chapterPayload.entry || entry;
            parsedEntries[index] = processedEntry;
            updateProgress(progressWrapper, progressFill, progressLabel, index + 1, totalChapters, `å®Œæˆç¬¬ ${index + 1}/${totalChapters} ç« `);
          }

          restructureChapters = parsedEntries;
          renderTable(parsedEntries);
          renderStatus("status3", "ç« èŠ‚æ¦‚è¿°å·²å®Œæˆå…¥åº“", "success");
          restructureTocButton.disabled = false;
          goToStep(4);
        } catch (error) {
          renderStatus("status3", error.message || "æ¦‚è¿°å…¥åº“å¤±è´¥", "error");
        } finally {
          hideProgress(progressWrapper, progressFill);
          if (parsedEntries.length) ingestButton.disabled = false;
        }
      });


      // ===== æ­¥éª¤4: é‡æ„ç›®å½• =====
      restructurePrompt.value = DEFAULT_RESTRUCTURE_PROMPT;

      restructureTocButton.addEventListener("click", async () => {
        if (!restructureChapters || restructureChapters.length === 0) {
          renderStatus("status4", "è¯·å…ˆå®Œæˆè§£æå…¥åº“", "error");
          return;
        }

        if (!restructurePrompt.value.trim()) {
          renderStatus("status4", "è¯·è¾“å…¥é‡æ„æç¤ºè¯", "error");
          return;
        }

        restructureTocButton.disabled = true;
        restructureTocButton.textContent = "é‡æ„ä¸­...";
        renderStatus("status4", "æ­£åœ¨è¯»å–ä¹¦ç±ç›®å½•ä¸æ‘˜è¦...", "info");

        try {
          const tocSummaryText = generateTocSummaryText(restructureChapters);
          renderStatus("status4", "æ­£åœ¨è°ƒç”¨æ·±åº¦æ€è€ƒæ¨¡å‹ç”Ÿæˆæ–°ç›®å½•...", "info");

          const userPrompt = restructurePrompt.value.trim();
          const fullPrompt = userPrompt.replace(/{chapters}/g, tocSummaryText);

          const result = await interpretWithDeepThinking(
            tocSummaryText,
            fullPrompt,
            { replacements: { chapters: tocSummaryText } }
          );

          restructuredTocContent = result.content;

          const thinkingContent = document.getElementById('thinkingContent');
          const thinkingDetails = document.getElementById('thinkingDetails');
          
          if (result.reasoning_content && thinkingContent) {
            thinkingContent.textContent = result.reasoning_content;
            thinkingDetails.style.display = 'block';
          } else {
            thinkingDetails.style.display = 'none';
          }
          
          const newTocPreview = document.getElementById('newTocPreview');
          if (result.content) {
            newTocPreview.textContent = result.content;
            newTocPreview.style.display = 'block';
          }

          if (result.content) {
            parsedParts = parseNewTocStructure(result.content);
            updatePartSelector();
          }
          
          renderStatus("status4", "ç›®å½•é‡æ„å®Œæˆï¼å¯ä»¥é€‰æ‹©Partæµ‹è¯•ï¼Œæˆ–ç‚¹å‡»ã€ç”Ÿæˆæ•´æœ¬æ–°ä¹¦ã€‘", "success");
          testPartButton.disabled = false;
          generateNewBookButton.disabled = false;
          goToStep(5);
        } catch (error) {
          renderStatus("status4", `é‡æ„å¤±è´¥: ${error.message}`, "error");
        } finally {
          restructureTocButton.disabled = false;
          restructureTocButton.textContent = "ğŸ”„ å¼€å§‹é‡æ„ç›®å½•";
        }
      });

      function updatePartSelector() {
        partSelector.innerHTML = '<option value="">é€‰æ‹©Partæµ‹è¯•...</option>';
        for (const part of parsedParts) {
          const coveredCount = part.coveredChapters ? part.coveredChapters.length : 0;
          partSelector.innerHTML += `<option value="${part.partNumber}">Part ${part.partNumber}: ${part.title.substring(0, 20)}${part.title.length > 20 ? '...' : ''} (${coveredCount}ç« )</option>`;
        }
      }

      // ===== æ­¥éª¤5: ç”Ÿæˆæ–°ä¹¦ =====
      testPartButton.addEventListener("click", async () => {
        const partNumber = parseInt(partSelector.value);
        if (!partNumber) {
          renderStatus("status5", "è¯·å…ˆé€‰æ‹©è¦æµ‹è¯•çš„Part", "error");
          return;
        }

        const part = parsedParts.find(p => p.partNumber === partNumber);
        if (!part) {
          renderStatus("status5", "æ‰¾ä¸åˆ°æŒ‡å®šçš„Part", "error");
          return;
        }

        const coveredIndices = part.coveredChapters || [];
        if (coveredIndices.length === 0) {
          renderStatus("status5", "è¯¥Partæ²¡æœ‰è¦†ç›–ä»»ä½•ç« èŠ‚", "error");
          return;
        }

        let combinedContent = '';
        console.log(`å¼€å§‹è·å–ç« èŠ‚å†…å®¹ï¼ŒrestructureChapters é•¿åº¦: ${restructureChapters.length}`);
        for (const chapterNum of coveredIndices) {
          const chapterIndex = chapterNum - 1;
          console.log(`å¤„ç†ç« èŠ‚ ${chapterNum} (ç´¢å¼• ${chapterIndex})`);
          if (chapterIndex >= 0 && chapterIndex < restructureChapters.length) {
            const chapter = restructureChapters[chapterIndex];
            console.log(`ç« èŠ‚ ${chapterNum}: title=${chapter.title}, contenté•¿åº¦=${(chapter.content || '').length}, content_zhé•¿åº¦=${(chapter.content_zh || '').length}`);
            const content = chapter.content_zh || chapter.content || '';
            if (content) combinedContent += (combinedContent ? '\n\n' : '') + content;
          } else {
            console.warn(`ç« èŠ‚ç´¢å¼• ${chapterIndex} è¶…å‡ºèŒƒå›´ (0-${restructureChapters.length - 1})`);
          }
        }

        if (!combinedContent) {
          console.log("è°ƒè¯•ä¿¡æ¯ - restructureChapters:", restructureChapters);
          console.log("è°ƒè¯•ä¿¡æ¯ - coveredIndices:", coveredIndices);
          renderStatus("status5", `æ— æ³•è·å–ç« èŠ‚å†…å®¹ã€‚è¯·ç¡®ä¿å·²å®Œæˆæ­¥éª¤3çš„è§£æå…¥åº“ï¼Œæˆ–ä»æ•°æ®åº“åŠ è½½äº†ä¹¦ç±ã€‚è¦†ç›–ç« èŠ‚: ${coveredIndices.join(',')}`, "error");
          return;
        }

        const maxLength = parseInt(restructureMaxWords.value) || 5000;
        
        // å†æ¬¡æ£€æŸ¥ combinedContent æ˜¯å¦ä¸ºç©º
        if (!combinedContent || combinedContent.trim().length === 0) {
          console.error("combinedContent ä¸ºç©ºï¼Œæ— æ³•å‘é€è¯·æ±‚");
          renderStatus("status5", "ç« èŠ‚å†…å®¹ä¸ºç©ºï¼Œæ— æ³•è¿›è¡Œåˆ†å‰²æµ‹è¯•", "error");
          return;
        }
        
        testPartButton.disabled = true;
        testPartButton.textContent = "æµ‹è¯•ä¸­...";
        renderStatus("status5", `æ­£åœ¨æµ‹è¯• Part ${partNumber}: ${part.title}...`, "info");

        try {
          const response = await fetch('/api/restructure/split-article', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: combinedContent.trim(), max_length: maxLength, title: part.title })
          });

          if (!response.ok) {
            const err = await response.json();
            throw new Error(err.error || 'åˆ†å‰²å¤±è´¥');
          }

          const result = await response.json();
          const segments = result.segments || [];

          if (segments.length === 0) throw new Error('åˆ†å‰²ç»“æœä¸ºç©º');

          const singlePartResult = document.getElementById('singlePartResult');
          let html = `<div style="margin-bottom: 12px; padding: 10px; background: #fef3c7; border-radius: 6px;">`;
          html += `<strong>Part ${partNumber}: ${escapeHtml(part.title)}</strong><br>`;
          html += `<span style="color: #92400e; font-size: 13px;">è¦†ç›–ç« èŠ‚: ${coveredIndices.join(', ')} | åˆ†å‰²æˆ ${segments.length} æ®µ</span>`;
          html += `</div>`;
          
          html += `<div style="display: grid; gap: 8px;">`;
          for (let i = 0; i < segments.length; i++) {
            const seg = segments[i];
            html += `<div style="padding: 10px; background: white; border: 1px solid #e5e7eb; border-radius: 6px;">`;
            html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
            html += `<span style="font-weight: 500;">${i + 1}. ${escapeHtml(seg.title)}</span>`;
            html += `<span style="color: #6b7280; font-size: 12px;">${(seg.word_count || 0).toLocaleString()}å­—</span>`;
            html += `</div></div>`;
          }
          html += `</div>`;
          
          singlePartResult.innerHTML = html;
          singlePartResult.style.display = 'block';
          renderStatus("status5", `Part ${partNumber} æµ‹è¯•å®Œæˆï¼å…± ${segments.length} ä¸ªæ®µè½`, "success");
        } catch (error) {
          renderStatus("status5", `æµ‹è¯•å¤±è´¥: ${error.message}`, "error");
        } finally {
          testPartButton.disabled = false;
          testPartButton.textContent = "ğŸ”„ æµ‹è¯•è¯¥Part";
        }
      });


      // ç”Ÿæˆæ•´æœ¬æ–°ä¹¦
      generateNewBookButton.addEventListener("click", async () => {
        if (!restructuredTocContent) {
          renderStatus("status5", "è¯·å…ˆå®Œæˆç›®å½•é‡æ„", "error");
          return;
        }

        const maxWordCount = parseInt(restructureMaxWords.value) || 5000;
        if (isNaN(maxWordCount) || maxWordCount <= 0) {
          renderStatus("status5", "åˆ†å‰²å­—æ•°ä¸Šé™è®¾ç½®æ— æ•ˆ", "error");
          return;
        }

        generateNewBookButton.disabled = true;
        generateNewBookButton.textContent = "ç”Ÿæˆä¸­...";
        showProgress(progressWrapper5, progressFill5, progressLabel5, parsedParts.length, "å¼€å§‹ç”Ÿæˆæ–°ä¹¦...");
        renderStatus("status5", "å¼€å§‹ç”Ÿæˆæ–°ä¹¦...", "info");

        try {
          renderStatus("status5", "æ­£åœ¨è§£ææ–°ç›®å½•ç»“æ„...", "info");
          const newParts = parseNewTocStructure(restructuredTocContent);
          
          if (newParts.length === 0) {
            throw new Error("æ— æ³•è§£ææ–°ç›®å½•ç»“æ„");
          }

          // åŒ¹é…åŸä¹¦ç±ç« èŠ‚å†…å®¹åˆ°æ–°ç›®å½•
          const matchedContent = [];
          for (const part of newParts) {
            let combinedContent = '';
            const matchedChapters = [];
            
            if (part.coveredChapters && part.coveredChapters.length > 0) {
              for (const chapterNum of part.coveredChapters) {
                const chapterIndex = chapterNum - 1;
                if (chapterIndex >= 0 && chapterIndex < restructureChapters.length) {
                  const chapter = restructureChapters[chapterIndex];
                  const content = chapter.content_zh || chapter.content || '';
                  if (content) {
                    combinedContent += content + '\n\n';
                    matchedChapters.push(chapter);
                  }
                }
              }
            }
            
            matchedContent.push({
              partNumber: part.partNumber,
              title: part.title,
              summary: part.summary || '',
              content: combinedContent.trim(),
              originalChapters: matchedChapters,
              coveredChapters: part.coveredChapters || []
            });
          }

          // é€ç« å¤„ç† - åˆå¹¶å†…å®¹å¹¶åˆ†å‰²
          const newBookChapters = [];
          
          for (let i = 0; i < matchedContent.length; i++) {
            const part = matchedContent[i];
            updateProgress(progressWrapper5, progressFill5, progressLabel5, i, matchedContent.length, `æ­£åœ¨å¤„ç†ç¬¬ ${i + 1}/${matchedContent.length} éƒ¨åˆ†ï¼š${part.title}`);
            renderStatus("status5", `æ­£åœ¨å¤„ç†ç¬¬ ${i + 1}/${matchedContent.length} éƒ¨åˆ†ï¼š${part.title}...`, "info");

            if (!part.content || part.content.trim().length === 0) {
              newBookChapters.push({
                partNumber: part.partNumber,
                title: part.title,
                summary: part.summary,
                segments: [{ title: part.title, content: "[è¯¥éƒ¨åˆ†æš‚æ— å†…å®¹]", word_count: 0 }]
              });
              continue;
            }

            try {
              const segments = await splitChapterContent(part.title, part.content, maxWordCount);
              newBookChapters.push({
                partNumber: part.partNumber,
                title: part.title,
                summary: part.summary,
                segments: segments
              });
            } catch (error) {
              console.error(`å¤„ç†ç¬¬ ${i + 1} éƒ¨åˆ†å¤±è´¥:`, error);
              newBookChapters.push({
                partNumber: part.partNumber,
                title: part.title,
                summary: part.summary,
                segments: [{ title: part.title, content: part.content, word_count: part.content.length, error: error.message }]
              });
            }
          }

          // ä¿å­˜æ–°ä¹¦ç±ç»“æ„
          newBookStructure = {
            originalFilename: currentFilename,
            newToc: restructuredTocContent,
            chapters: newBookChapters,
            maxWordCount: maxWordCount,
            generatedAt: new Date().toISOString()
          };

          // æ¸²æŸ“ç›®å½•æ ‘
          renderNewBookTocTree(newBookChapters);
          
          // æ›´æ–°æ‘˜è¦ä¿¡æ¯
          const totalSegments = newBookChapters.reduce((sum, ch) => sum + ch.segments.length, 0);
          document.getElementById('newBookSummary').textContent = `å…± ${newBookChapters.length} ä¸ªéƒ¨åˆ†ï¼Œ${totalSegments} ä¸ªæ®µè½`;
          
          document.getElementById('newBookPreview').style.display = 'block';
          hideProgress(progressWrapper5, progressFill5);
          renderStatus("status5", `æ–°ä¹¦ç”Ÿæˆå®Œæˆï¼å…± ${newBookChapters.length} ä¸ªéƒ¨åˆ†`, "success");
          
          newBookName.value = currentFilename.replace(/\.(pdf|epub)$/i, '') + '_é‡æ„ç‰ˆ';
          saveNewBookButton.disabled = false;
          goToStep(6);
        } catch (error) {
          renderStatus("status5", `ç”Ÿæˆå¤±è´¥: ${error.message}`, "error");
          hideProgress(progressWrapper5, progressFill5);
        } finally {
          generateNewBookButton.disabled = false;
          generateNewBookButton.textContent = "ğŸ“– ç”Ÿæˆæ•´æœ¬æ–°ä¹¦";
        }
      });

      function renderNewBookTocTree(chapters) {
        const tocTree = document.getElementById('newBookTocTree');
        if (!tocTree || !chapters) return;
        
        let html = '';
        for (const chapter of chapters) {
          html += `<div style="margin-bottom: 8px;">`;
          html += `<div style="padding: 8px 12px; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: white; border-radius: 6px; font-weight: 600; font-size: 13px; cursor: pointer;" onclick="togglePartExpand(${chapter.partNumber})">`;
          html += `<span id="partIcon${chapter.partNumber}">â–¼</span> Part ${chapter.partNumber}ï¼š${escapeHtml(chapter.title.substring(0, 15))}${chapter.title.length > 15 ? '...' : ''}`;
          html += `</div>`;
          html += `<div id="partSegments${chapter.partNumber}" style="margin-left: 12px; margin-top: 4px;">`;
          for (let j = 0; j < chapter.segments.length; j++) {
            const segment = chapter.segments[j];
            html += `<div class="toc-segment-item" data-part="${chapter.partNumber - 1}" data-seg="${j}" onclick="selectNewBookSegment(${chapter.partNumber - 1}, ${j})" style="padding: 6px 10px; margin: 2px 0; border-radius: 4px; font-size: 12px; color: #475569; cursor: pointer; border-left: 2px solid #e2e8f0;">`;
            html += `${j + 1}. ${escapeHtml(segment.title.substring(0, 20))}${segment.title.length > 20 ? '...' : ''}`;
            html += `<span style="color: #94a3b8; font-size: 11px; margin-left: 4px;">(${(segment.word_count || 0).toLocaleString()}å­—)</span>`;
            html += `</div>`;
          }
          html += `</div></div>`;
        }
        tocTree.innerHTML = html;
      }
      
      window.togglePartExpand = function(partNumber) {
        const segments = document.getElementById(`partSegments${partNumber}`);
        const icon = document.getElementById(`partIcon${partNumber}`);
        if (segments && icon) {
          segments.style.display = segments.style.display === 'none' ? 'block' : 'none';
          icon.textContent = segments.style.display === 'none' ? 'â–¶' : 'â–¼';
        }
      };
      
      window.selectNewBookSegment = function(partIndex, segmentIndex) {
        if (!newBookStructure || !newBookStructure.chapters) return;
        const chapter = newBookStructure.chapters[partIndex];
        if (!chapter || !chapter.segments) return;
        const segment = chapter.segments[segmentIndex];
        if (!segment) return;
        
        document.querySelectorAll('.toc-segment-item').forEach(item => {
          item.style.background = 'transparent';
          item.style.borderLeftColor = '#e2e8f0';
        });
        const selectedItem = document.querySelector(`.toc-segment-item[data-part="${partIndex}"][data-seg="${segmentIndex}"]`);
        if (selectedItem) {
          selectedItem.style.background = '#e0e7ff';
          selectedItem.style.borderLeftColor = '#6366f1';
        }
        
        const previewTitle = document.getElementById('previewTitle');
        if (previewTitle) {
          previewTitle.innerHTML = `ğŸ“„ Part ${chapter.partNumber} - ${escapeHtml(segment.title)} <span style="color: #94a3b8; font-size: 12px;">(${(segment.word_count || 0).toLocaleString()}å­—)</span>`;
        }
        const contentPreview = document.getElementById('newBookContentPreview');
        if (contentPreview) {
          contentPreview.innerHTML = `<div style="white-space: pre-wrap; line-height: 1.8;">${escapeHtml(segment.content)}</div>`;
          contentPreview.scrollTop = 0;
        }
      };


      // ===== æ­¥éª¤6: æ–°ä¹¦å…¥åº“ =====
      saveNewBookButton.addEventListener("click", async () => {
        if (!newBookStructure || !newBookStructure.chapters) {
          renderStatus("status6", "æ²¡æœ‰å¯ä¿å­˜çš„æ–°ä¹¦æ•°æ®", "error");
          return;
        }

        const bookName = newBookName.value.trim();
        if (!bookName) {
          renderStatus("status6", "è¯·è¾“å…¥æ–°ä¹¦åç§°", "error");
          return;
        }

        saveNewBookButton.disabled = true;
        saveNewBookButton.textContent = "ä¿å­˜ä¸­...";
        renderStatus("status6", "æ­£åœ¨ä¿å­˜æ–°ä¹¦åˆ°æ•°æ®åº“...", "info");

        try {
          const entries = [];
          for (const part of newBookStructure.chapters) {
            for (const segment of part.segments) {
              entries.push({
                title: segment.title,
                title_zh: segment.title,
                content: segment.content,
                content_zh: segment.content,
                word_count: segment.word_count || 0,
                summary: part.summary || ''
              });
            }
          }

          if (entries.length === 0) throw new Error('æ²¡æœ‰å¯ä¿å­˜çš„ç« èŠ‚');

          const totalWordCount = entries.reduce((sum, e) => sum + (e.word_count || 0), 0);
          const newFilename = bookName.endsWith('.pdf') || bookName.endsWith('.epub') ? bookName : `${bookName}.pdf`;

          renderStatus("status6", "æ­£åœ¨åˆ›å»ºæ–°ä¹¦è®°å½•...", "info");

          const startRes = await fetch('/api/parse/ingest/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              filename: newFilename,
              chapter_count: entries.length,
              total_word_count: totalWordCount
            })
          });

          if (!startRes.ok) {
            const err = await startRes.json();
            throw new Error(err.error || 'åˆ›å»ºä¹¦ç±è®°å½•å¤±è´¥');
          }

          const startData = await startRes.json();
          const bookId = startData.book_id;

          for (let i = 0; i < entries.length; i++) {
            renderStatus("status6", `æ­£åœ¨ä¿å­˜ç¬¬ ${i + 1}/${entries.length} ç« ...`, "info");
            await fetch('/api/parse/ingest/chapter', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ book_id: bookId, entry: entries[i], index: i })
            });
          }

          renderStatus("status6", `ğŸ‰ æ–°ä¹¦ä¿å­˜æˆåŠŸï¼ä¹¦ç±ID: ${bookId}ï¼Œå…± ${entries.length} ç« `, "success");
          alert(`æ–°ä¹¦ä¿å­˜æˆåŠŸï¼\n\nä¹¦åï¼š${newFilename}\nç« èŠ‚æ•°ï¼š${entries.length}\næ€»å­—æ•°ï¼š${totalWordCount.toLocaleString()}\n\nå¯åœ¨ã€Œä¹¦ç±ç®¡ç†ã€é¡µé¢æŸ¥çœ‹`);
        } catch (error) {
          renderStatus("status6", `ä¿å­˜å¤±è´¥: ${error.message}`, "error");
        } finally {
          saveNewBookButton.disabled = false;
          saveNewBookButton.textContent = "ğŸ’¾ ä¿å­˜åˆ°æ•°æ®åº“";
        }
      });

      // ==================== å·¥ä½œæµäºŒï¼šä¹¦ç±è§£è¯» ====================
      
      // å·¥ä½œæµäºŒçš„çŠ¶æ€
      let w2SelectedBook = null;
      let w2Chapters = [];
      let w2SelectedChapterIndex = null;
      let w2CurrentStep = 1;
      let w2AllResults = []; // å­˜å‚¨å…¨ä¹¦è§£è¯»ç»“æœ

      // å·¥ä½œæµäºŒçš„ DOM å…ƒç´ 
      const w2BookSelect = document.getElementById('w2BookSelect');
      const w2ChapterSelect = document.getElementById('w2ChapterSelect');
      const w2PromptText = document.getElementById('w2PromptText');
      const w2GenerateBtn = document.getElementById('w2GenerateBtn');
      const w2GenerateAllBtn = document.getElementById('w2GenerateAllBtn');
      const w2CopyBtn = document.getElementById('w2CopyBtn');

      // å·¥ä½œæµåˆ‡æ¢
      document.querySelectorAll('.workflow-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const workflow = parseInt(tab.dataset.workflow);
          switchWorkflow(workflow);
        });
      });

      function switchWorkflow(workflow) {
        currentWorkflow = workflow;
        
        // æ›´æ–° Tab æ ·å¼
        document.querySelectorAll('.workflow-tab').forEach(t => {
          t.classList.toggle('active', parseInt(t.dataset.workflow) === workflow);
        });
        
        // åˆ‡æ¢å·¥ä½œæµå†…å®¹
        document.getElementById('workflow1').style.display = workflow === 1 ? 'block' : 'none';
        document.getElementById('workflow2').style.display = workflow === 2 ? 'block' : 'none';
        
        // å¦‚æœåˆ‡æ¢åˆ°å·¥ä½œæµäºŒï¼ŒåŠ è½½ä¹¦ç±åˆ—è¡¨
        if (workflow === 2 && w2BookSelect.options.length <= 1) {
          w2LoadBooks();
        }
      }

      // å·¥ä½œæµäºŒï¼šåŠ è½½ä¹¦ç±åˆ—è¡¨
      async function w2LoadBooks() {
        renderStatus('w2Status1', 'æ­£åœ¨åŠ è½½ä¹¦ç±åˆ—è¡¨...', 'info');
        try {
          const response = await fetch('/api/admin/books?page=1&per_page=100');
          const data = await response.json();
          if (data.error) throw new Error(data.error);
          
          const books = data.books || [];
          w2BookSelect.innerHTML = '<option value="">è¯·é€‰æ‹©å·²å…¥åº“çš„ä¹¦ç±...</option>';
          books.forEach(book => {
            const option = document.createElement('option');
            option.value = book.id;
            option.textContent = `${book.filename} (${book.chapter_count}ç« , ${(book.total_word_count || 0).toLocaleString()}å­—)`;
            w2BookSelect.appendChild(option);
          });
          
          document.getElementById('w2Status1').style.display = 'none';
        } catch (error) {
          renderStatus('w2Status1', `åŠ è½½ä¹¦ç±å¤±è´¥: ${error.message}`, 'error');
        }
      }

      // å·¥ä½œæµäºŒï¼šé€‰æ‹©ä¹¦ç±
      w2BookSelect.addEventListener('change', async (e) => {
        const bookId = e.target.value;
        if (!bookId) {
          w2SelectedBook = null;
          w2Chapters = [];
          document.getElementById('w2BookInfo').style.display = 'none';
          document.getElementById('w2Panel2').classList.add('hidden');
          document.getElementById('w2Panel3').classList.add('hidden');
          return;
        }
        
        renderStatus('w2Status1', 'æ­£åœ¨åŠ è½½ä¹¦ç±è¯¦æƒ…...', 'info');
        try {
          const response = await fetch(`/api/admin/books/${bookId}`);
          const data = await response.json();
          if (data.error) throw new Error(data.error);
          
          w2SelectedBook = data.book;
          w2Chapters = data.chapters || [];
          
          // æ˜¾ç¤ºä¹¦ç±ä¿¡æ¯
          document.getElementById('w2BookTitle').textContent = `ğŸ“š ${w2SelectedBook.filename}`;
          document.getElementById('w2BookStats').textContent = `å…± ${w2Chapters.length} ç« ï¼Œ${(w2SelectedBook.total_word_count || 0).toLocaleString()} å­—`;
          document.getElementById('w2BookInfo').style.display = 'block';
          
          // å¡«å……ç« èŠ‚é€‰æ‹©
          w2ChapterSelect.innerHTML = '<option value="">è¯·é€‰æ‹©ç« èŠ‚...</option>';
          w2ChapterSelect.innerHTML += '<option value="all">ğŸ“– å…¨éƒ¨ç« èŠ‚ï¼ˆç”Ÿæˆæ•´æœ¬ä¹¦è§£è¯»ï¼‰</option>';
          w2Chapters.forEach((chapter, index) => {
            const option = document.createElement('option');
            option.value = index;
            const title = chapter.title_zh || chapter.title || `ç¬¬${index + 1}ç« `;
            const wordCount = chapter.word_count || 0;
            option.textContent = `${index + 1}. ${title} (${wordCount.toLocaleString()}å­—)`;
            w2ChapterSelect.appendChild(option);
          });
          
          // æ˜¾ç¤ºæ­¥éª¤2
          document.getElementById('w2Panel2').classList.remove('hidden');
          w2GoToStep(2);
          
          document.getElementById('w2Status1').style.display = 'none';
        } catch (error) {
          renderStatus('w2Status1', `åŠ è½½ä¹¦ç±å¤±è´¥: ${error.message}`, 'error');
        }
      });

      // å·¥ä½œæµäºŒï¼šé€‰æ‹©ç« èŠ‚
      w2ChapterSelect.addEventListener('change', (e) => {
        const value = e.target.value;
        
        if (value === '') {
          w2SelectedChapterIndex = null;
          document.getElementById('w2ChapterInfo').style.display = 'none';
          document.getElementById('w2Panel3').classList.add('hidden');
          w2GenerateBtn.style.display = 'inline-block';
          w2GenerateAllBtn.style.display = 'none';
          return;
        }
        
        if (value === 'all') {
          // é€‰æ‹©å…¨éƒ¨ç« èŠ‚
          w2SelectedChapterIndex = 'all';
          document.getElementById('w2ChapterTitle').textContent = `ğŸ“– å…¨éƒ¨ç« èŠ‚`;
          const totalWords = w2Chapters.reduce((sum, ch) => sum + (ch.word_count || 0), 0);
          document.getElementById('w2ChapterStats').textContent = `å…± ${w2Chapters.length} ç« ï¼Œ${totalWords.toLocaleString()} å­—`;
          document.getElementById('w2ChapterInfo').style.display = 'block';
          
          // æ˜¾ç¤ºå…¨ä¹¦è§£è¯»æŒ‰é’®
          w2GenerateBtn.style.display = 'none';
          w2GenerateAllBtn.style.display = 'inline-block';
          w2GenerateAllBtn.disabled = false;
        } else {
          // é€‰æ‹©å•ä¸ªç« èŠ‚
          w2SelectedChapterIndex = parseInt(value);
          const chapter = w2Chapters[w2SelectedChapterIndex];
          const title = chapter.title_zh || chapter.title || `ç¬¬${w2SelectedChapterIndex + 1}ç« `;
          document.getElementById('w2ChapterTitle').textContent = `ğŸ“‘ ${title}`;
          document.getElementById('w2ChapterStats').textContent = `${(chapter.word_count || 0).toLocaleString()} å­—`;
          document.getElementById('w2ChapterInfo').style.display = 'block';
          
          // æ˜¾ç¤ºå•ç« è§£è¯»æŒ‰é’®
          w2GenerateBtn.style.display = 'inline-block';
          w2GenerateAllBtn.style.display = 'none';
          w2GenerateBtn.disabled = false;
        }
        
        // æ˜¾ç¤ºæ­¥éª¤3
        document.getElementById('w2Panel3').classList.remove('hidden');
        w2GoToStep(3);
      });

      // å·¥ä½œæµäºŒï¼šæ­¥éª¤å¯¼èˆª
      function w2GoToStep(step) {
        w2CurrentStep = step;
        document.querySelectorAll('#workflow2 .step-item').forEach((item, index) => {
          item.classList.remove('active', 'done');
          if (index + 1 < step) item.classList.add('done');
          else if (index + 1 === step) item.classList.add('active');
        });
      }

      // å·¥ä½œæµäºŒï¼šåŠ è½½æç¤ºè¯
      function w2LoadPrompt() {
        const saved = localStorage.getItem('w2InterpretationPrompt');
        w2PromptText.value = saved || DEFAULT_INTERPRETATION_PROMPT;
      }

      // å·¥ä½œæµäºŒï¼šä¿å­˜æç¤ºè¯
      window.w2SavePrompt = function() {
        localStorage.setItem('w2InterpretationPrompt', w2PromptText.value);
        renderStatus('w2Status3', 'æç¤ºè¯å·²ä¿å­˜', 'success');
        setTimeout(() => { document.getElementById('w2Status3').style.display = 'none'; }, 2000);
      };

      // å·¥ä½œæµäºŒï¼šé‡ç½®æç¤ºè¯
      window.w2ResetPrompt = function() {
        if (confirm('ç¡®å®šè¦é‡ç½®ä¸ºé»˜è®¤æç¤ºè¯å—ï¼Ÿ')) {
          w2PromptText.value = DEFAULT_INTERPRETATION_PROMPT;
          localStorage.removeItem('w2InterpretationPrompt');
          renderStatus('w2Status3', 'å·²é‡ç½®ä¸ºé»˜è®¤æç¤ºè¯', 'success');
          setTimeout(() => { document.getElementById('w2Status3').style.display = 'none'; }, 2000);
        }
      };

      // å·¥ä½œæµäºŒï¼šç”Ÿæˆå•ç« è§£è¯»
      w2GenerateBtn.addEventListener('click', async () => {
        if (w2SelectedChapterIndex === null || w2SelectedChapterIndex === 'all') return;
        
        const chapter = w2Chapters[w2SelectedChapterIndex];
        const content = chapter.content_zh || chapter.content || '';
        if (!content.trim()) {
          renderStatus('w2Status3', 'ç« èŠ‚å†…å®¹ä¸ºç©ºï¼Œæ— æ³•ç”Ÿæˆè§£è¯»', 'error');
          return;
        }
        
        w2GenerateBtn.disabled = true;
        w2GenerateBtn.innerHTML = '<span class="loading"></span>ç”Ÿæˆä¸­...';
        renderStatus('w2Status3', 'æ­£åœ¨è°ƒç”¨æ·±åº¦æ€è€ƒæ¨¡å‹ç”Ÿæˆè§£è¯»æ–‡ç« ï¼Œè¯·ç¨å€™ï¼ˆçº¦1-3åˆ†é’Ÿï¼‰...', 'info');
        
        // éšè—ä¹‹å‰çš„ç»“æœ
        document.getElementById('w2ResultContainer').style.display = 'none';
        document.getElementById('w2ThinkingBox').style.display = 'none';
        w2CopyBtn.style.display = 'none';
        
        try {
          const prompt = w2PromptText.value.replace(/{BOOK_CHAPTER}/g, content);
          
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 300000);
          
          const response = await fetch('/api/test/doubao-thinking', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: prompt,
              temperature: 0.3,
              max_tokens: 16000,
              model: 'doubao-seed-1.6-thinking-250715'
            }),
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP ${response.status}`);
          }
          
          const data = await response.json();
          
          // æ˜¾ç¤ºæ€è€ƒè¿‡ç¨‹
          if (data.reasoning_content) {
            document.getElementById('w2ThinkingContent').textContent = data.reasoning_content;
            document.getElementById('w2ThinkingBox').style.display = 'block';
          }
          
          // æå–è§£è¯»å†…å®¹
          let interpretation = data.content || '';
          interpretation = interpretation.replace(/<\/?è§£è¯»>/g, '').trim();
          
          // æ˜¾ç¤ºç»“æœ
          document.getElementById('w2ResultContent').innerHTML = marked.parse(interpretation);
          const wordCount = interpretation.replace(/\s+/g, '').length;
          document.getElementById('w2ResultWordCount').textContent = `è§£è¯»æ–‡ç« å­—æ•°ï¼š${wordCount.toLocaleString()} å­—`;
          document.getElementById('w2ResultContainer').style.display = 'block';
          w2CopyBtn.style.display = 'inline-block';
          
          renderStatus('w2Status3', `è§£è¯»æ–‡ç« ç”Ÿæˆå®Œæˆï¼å…± ${wordCount.toLocaleString()} å­—`, 'success');
          
        } catch (error) {
          let errorMessage = 'ç”Ÿæˆå¤±è´¥';
          if (error.name === 'AbortError') {
            errorMessage = 'è¯·æ±‚è¶…æ—¶ï¼ˆè¶…è¿‡5åˆ†é’Ÿï¼‰ï¼Œè¯·ç¨åé‡è¯•';
          } else if (error.message) {
            errorMessage = error.message;
          }
          renderStatus('w2Status3', `ç”Ÿæˆå¤±è´¥: ${errorMessage}`, 'error');
        } finally {
          w2GenerateBtn.disabled = false;
          w2GenerateBtn.textContent = 'ğŸš€ ç”Ÿæˆè§£è¯»æ–‡ç« ';
        }
      });

      // å·¥ä½œæµäºŒï¼šç”Ÿæˆå…¨ä¹¦è§£è¯»
      w2GenerateAllBtn.addEventListener('click', async () => {
        if (w2SelectedChapterIndex !== 'all' || w2Chapters.length === 0) return;
        
        w2GenerateAllBtn.disabled = true;
        w2GenerateAllBtn.innerHTML = '<span class="loading"></span>ç”Ÿæˆä¸­...';
        w2AllResults = [];
        
        // æ˜¾ç¤ºè¿›åº¦æ¡
        const progressWrapper = document.getElementById('w2ProgressWrapper');
        const progressFill = document.getElementById('w2ProgressFill');
        const progressLabel = document.getElementById('w2ProgressLabel');
        progressWrapper.style.display = 'block';
        
        // éšè—ä¹‹å‰çš„ç»“æœ
        document.getElementById('w2ResultContainer').style.display = 'none';
        document.getElementById('w2ThinkingBox').style.display = 'none';
        document.getElementById('w2AllResultsContainer').style.display = 'none';
        
        try {
          for (let i = 0; i < w2Chapters.length; i++) {
            const chapter = w2Chapters[i];
            const content = chapter.content_zh || chapter.content || '';
            const title = chapter.title_zh || chapter.title || `ç¬¬${i + 1}ç« `;
            
            // æ›´æ–°è¿›åº¦
            const percent = Math.round(((i) / w2Chapters.length) * 100);
            progressFill.style.width = `${percent}%`;
            progressLabel.textContent = `æ­£åœ¨ç”Ÿæˆç¬¬ ${i + 1}/${w2Chapters.length} ç« ï¼š${title}`;
            renderStatus('w2Status3', `æ­£åœ¨ç”Ÿæˆç¬¬ ${i + 1}/${w2Chapters.length} ç« çš„è§£è¯»...`, 'info');
            
            if (!content.trim()) {
              w2AllResults.push({ title, content: 'ï¼ˆç« èŠ‚å†…å®¹ä¸ºç©ºï¼‰', wordCount: 0 });
              continue;
            }
            
            const prompt = w2PromptText.value.replace(/{BOOK_CHAPTER}/g, content);
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 300000);
            
            const response = await fetch('/api/test/doubao-thinking', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                prompt: prompt,
                temperature: 0.3,
                max_tokens: 16000,
                model: 'doubao-seed-1.6-thinking-250715'
              }),
              signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));
              w2AllResults.push({ title, content: `ç”Ÿæˆå¤±è´¥: ${errorData.error || 'HTTP ' + response.status}`, wordCount: 0 });
              continue;
            }
            
            const data = await response.json();
            let interpretation = data.content || '';
            interpretation = interpretation.replace(/<\/?è§£è¯»>/g, '').trim();
            const wordCount = interpretation.replace(/\s+/g, '').length;
            
            w2AllResults.push({ title, content: interpretation, wordCount });
          }
          
          // å®Œæˆ
          progressFill.style.width = '100%';
          progressLabel.textContent = 'å…¨éƒ¨å®Œæˆï¼';
          
          // æ˜¾ç¤ºå…¨ä¹¦è§£è¯»ç»“æœ
          w2RenderAllResults();
          document.getElementById('w2AllResultsContainer').style.display = 'block';
          
          const totalWords = w2AllResults.reduce((sum, r) => sum + r.wordCount, 0);
          renderStatus('w2Status3', `å…¨ä¹¦è§£è¯»ç”Ÿæˆå®Œæˆï¼å…± ${w2Chapters.length} ç« ï¼Œ${totalWords.toLocaleString()} å­—`, 'success');
          
        } catch (error) {
          renderStatus('w2Status3', `ç”Ÿæˆå¤±è´¥: ${error.message}`, 'error');
        } finally {
          w2GenerateAllBtn.disabled = false;
          w2GenerateAllBtn.textContent = 'ğŸ“š ç”Ÿæˆå…¨ä¹¦è§£è¯»';
          setTimeout(() => { progressWrapper.style.display = 'none'; }, 2000);
        }
      });

      // å·¥ä½œæµäºŒï¼šæ¸²æŸ“å…¨ä¹¦è§£è¯»ç»“æœ
      function w2RenderAllResults() {
        const container = document.getElementById('w2AllResultsList');
        let html = '';
        
        w2AllResults.forEach((result, index) => {
          html += `<details style="margin-bottom: 12px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">`;
          html += `<summary style="padding: 12px 16px; cursor: pointer; font-weight: 600; color: #1e293b;">`;
          html += `${index + 1}. ${escapeHtml(result.title)} <span style="font-weight: normal; color: #64748b;">(${result.wordCount.toLocaleString()}å­—)</span>`;
          html += `</summary>`;
          html += `<div style="padding: 16px; border-top: 1px solid #e2e8f0; line-height: 1.8; font-size: 14px;">`;
          html += marked.parse(result.content);
          html += `</div></details>`;
        });
        
        container.innerHTML = html;
      }

      // å·¥ä½œæµäºŒï¼šå¤åˆ¶å•ç« ç»“æœ
      w2CopyBtn.addEventListener('click', () => {
        const text = document.getElementById('w2ResultContent').innerText;
        navigator.clipboard.writeText(text).then(() => {
          const originalText = w2CopyBtn.textContent;
          w2CopyBtn.textContent = 'âœ… å·²å¤åˆ¶';
          setTimeout(() => { w2CopyBtn.textContent = originalText; }, 2000);
        });
      });

      // å·¥ä½œæµäºŒï¼šå¤åˆ¶å…¨éƒ¨ç»“æœ
      document.getElementById('w2CopyAllBtn')?.addEventListener('click', () => {
        let allText = '';
        w2AllResults.forEach((result, index) => {
          allText += `## ${index + 1}. ${result.title}\n\n`;
          allText += result.content + '\n\n---\n\n';
        });
        
        navigator.clipboard.writeText(allText).then(() => {
          const btn = document.getElementById('w2CopyAllBtn');
          const originalText = btn.textContent;
          btn.textContent = 'âœ… å·²å¤åˆ¶';
          setTimeout(() => { btn.textContent = originalText; }, 2000);
        });
      });

      // å·¥ä½œæµäºŒï¼šåˆ·æ–°ä¹¦ç±åˆ—è¡¨
      document.getElementById('w2RefreshBooks')?.addEventListener('click', w2LoadBooks);

      // ===== åˆå§‹åŒ– =====
      document.addEventListener("DOMContentLoaded", () => {
        goToStep(1);
        w2LoadPrompt(); // åŠ è½½å·¥ä½œæµäºŒçš„æç¤ºè¯
        
        // é«˜äº®å½“å‰å¯¼èˆª
        const currentPath = window.location.pathname;
        document.querySelectorAll('.nav-link').forEach(link => {
          const href = link.getAttribute('href');
          if (href === currentPath || currentPath.endsWith(href)) {
            link.classList.add('active');
          } else {
            link.classList.remove('active');
          }
        });
      });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  </body>
</html>