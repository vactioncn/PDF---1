<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>PDF è‡ªåŠ¨åŒ–è§£ææµ‹è¯•å°</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      :root {
        color-scheme: light;
        font-family: "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
        background-color: #f8fafc;
        color: #0f172a;
      }

      /* å¯¼èˆªæ æ ·å¼ */
      .top-navbar {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 12px 20px;
        margin: -24px -24px 24px -24px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 0;
        z-index: 1000;
      }

      .nav-container {
        max-width: 1400px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 20px;
        flex-wrap: wrap;
      }

      .nav-brand {
        color: white;
        font-weight: 600;
        font-size: 18px;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .nav-brand:hover {
        opacity: 0.9;
      }

      .nav-links {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .nav-link {
        color: white;
        text-decoration: none;
        padding: 8px 14px;
        border-radius: 6px;
        font-size: 14px;
        transition: all 0.2s;
        white-space: nowrap;
      }

      .nav-link:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .nav-link.active {
        background: rgba(255, 255, 255, 0.25);
        font-weight: 500;
      }

      body {
        margin: 0;
        padding: 24px;
        max-width: 1400px;
        margin: 0 auto;
      }

      h1 {
        margin-top: 0;
        margin-bottom: 8px;
        font-size: 32px;
        font-weight: 600;
        color: #0f172a;
      }

      .subtitle {
        color: #64748b;
        font-size: 14px;
        margin-bottom: 32px;
      }

      .panel {
        background: #ffffff;
        border-radius: 16px;
        padding: 28px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        margin-bottom: 24px;
        border: 1px solid #e2e8f0;
      }

      .panel h2 {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 20px;
        font-weight: 600;
        color: #1e293b;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: flex-start;
      }

      .control-group {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        flex: 1;
        min-width: 300px;
      }

      .control-group.primary {
        flex: 2;
        min-width: 400px;
      }

      input[type="file"] {
        flex: 1;
        min-width: 200px;
        padding: 10px 14px;
        border: 1.5px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
        background: #ffffff;
        transition: border-color 0.2s, box-shadow 0.2s;
      }

      input[type="file"]:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      input[type="password"],
      input[type="text"] {
        flex: 1;
        min-width: 180px;
        padding: 10px 14px;
        border: 1.5px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
        background: #ffffff;
        transition: border-color 0.2s, box-shadow 0.2s;
      }

      input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        margin-right: 8px;
      }

      label.checkbox-label {
        display: flex;
        align-items: center;
        font-size: 14px;
        color: #1e293b;
        cursor: pointer;
        user-select: none;
      }

      input[type="password"]:focus,
      input[type="text"]:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      button {
        padding: 10px 20px;
        border-radius: 8px;
        border: none;
        background: #2563eb;
        color: white;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      button.secondary {
        background: #10b981;
      }

      button:disabled {
        background: #cbd5e1;
        color: #94a3b8;
        cursor: not-allowed;
        transform: none;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
      }

      button.secondary:hover:not(:disabled) {
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
      }

      button:active:not(:disabled) {
        transform: translateY(0);
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        border-radius: 12px;
        overflow: hidden;
        background: #ffffff;
      }

      thead {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      th {
        padding: 16px;
        text-align: left;
        font-weight: 600;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      td {
        padding: 16px;
        text-align: left;
        border-bottom: 1px solid #e2e8f0;
        vertical-align: top;
        font-size: 14px;
      }

      tbody tr {
        transition: background-color 0.15s ease;
      }

      tbody tr:hover {
        background: rgba(102, 126, 234, 0.05);
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      .status {
        margin-top: 16px;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        background: #f1f5f9;
        border-left: 4px solid #cbd5e1;
      }

      .status.info {
        background: #eff6ff;
        border-left-color: #3b82f6;
        color: #1e40af;
      }

      .status.success {
        background: #f0fdf4;
        border-left-color: #10b981;
        color: #065f46;
      }

      .status.error {
        background: #fef2f2;
        border-left-color: #ef4444;
        color: #991b1b;
      }

      .progress-wrapper {
        margin-bottom: 20px;
        display: none;
      }

      .progress-wrapper.active {
        display: block;
      }

      .progress-label {
        font-size: 14px;
        color: #475569;
        margin-bottom: 8px;
        font-weight: 500;
      }

      .progress-bar {
        width: 100%;
        height: 10px;
        border-radius: 999px;
        background: #e2e8f0;
        overflow: hidden;
        position: relative;
      }

      .progress-fill {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 0%;
        border-radius: 999px;
        background: linear-gradient(135deg, #4f46e5 0%, #14b8a6 100%);
        transition: width 0.3s ease;
      }

      .loading {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid rgba(0, 0, 0, 0.1);
        border-top-color: currentColor;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        margin-right: 8px;
        vertical-align: middle;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      @media (max-width: 768px) {
        body {
          padding: 16px;
        }

        .panel {
          padding: 20px;
        }

        .control-group {
          min-width: 100%;
        }

        .control-group.primary {
          min-width: 100%;
        }

        table {
          font-size: 12px;
        }

        th,
        td {
          padding: 12px 8px;
        }

        button {
          font-size: 13px;
          padding: 8px 16px;
        }
      }

      dialog {
        border: none;
        border-radius: 16px;
        padding: 0;
        width: min(800px, 90vw);
        max-height: 85vh;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      }

      dialog h3 {
        margin: 0;
        padding: 24px 28px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        font-size: 20px;
        font-weight: 600;
        border-radius: 16px 16px 0 0;
      }

      dialog .modal-body {
        padding: 24px 28px;
        overflow-y: auto;
        max-height: calc(85vh - 140px);
        white-space: pre-wrap;
        line-height: 1.8;
        color: #334155;
        font-size: 14px;
      }

      dialog > div:last-child {
        padding: 20px 28px;
        background: #f8fafc;
        border-radius: 0 0 16px 16px;
        border-top: 1px solid #e2e8f0;
      }

      dialog::backdrop {
        background-color: rgba(15, 23, 42, 0.5);
        backdrop-filter: blur(4px);
      }
    </style>
  </head>
  <body>
    <!-- å¯¼èˆªæ  -->
    <nav class="top-navbar">
      <div class="nav-container">
        <a href="/" class="nav-brand">ğŸ“š PDFè§£è¯»ç³»ç»Ÿ</a>
        <div class="nav-links">
          <a href="/" class="nav-link">ğŸ  é¦–é¡µ</a>
          <a href="/aigen_test_page.html" class="nav-link">âœ¨ ä¸ªæ€§åŒ–è§£è¯»</a>
          <a href="/test_doubao_thinking.html" class="nav-link">ğŸ§  æ·±åº¦æ€è€ƒæµ‹è¯•</a>
          <a href="/test_thinking.html" class="nav-link">ğŸ”¬ æ€è€ƒæ¨¡å‹æµ‹è¯•</a>
          <a href="/parser_test_page.html" class="nav-link">ğŸ“„ æ–‡æ¡£è§£æ</a>
          <a href="/admin_books.html" class="nav-link">ğŸ“– ä¹¦ç±ç®¡ç†</a>
          <a href="/admin.html" class="nav-link">âš™ï¸ ç³»ç»Ÿç®¡ç†</a>
        </div>
      </div>
    </nav>

    <h1>æ–‡æ¡£è‡ªåŠ¨åŒ–è§£ææµ‹è¯•å°</h1>
    <p class="subtitle">ä¸Šä¼  PDF æˆ– EPUB æ–‡ä»¶ï¼Œè‡ªåŠ¨æå–ç›®å½•ç« èŠ‚å¹¶ç”Ÿæˆæ¦‚è¿°</p>

    <!-- Tab åˆ‡æ¢ -->
    <div style="margin-bottom: 24px; border-bottom: 2px solid #e2e8f0;">
      <div style="display: flex; gap: 8px; margin: 0 24px;">
        <button id="mainTabBtn" class="tab-button active" style="padding: 12px 24px; background: transparent; border: none; border-bottom: 3px solid #2563eb; color: #2563eb; font-weight: 600; font-size: 15px; cursor: pointer; transition: all 0.2s;">
          ğŸ“„ æ–‡æ¡£è§£æ
        </button>
        <button id="splitTestTabBtn" class="tab-button" style="padding: 12px 24px; background: transparent; border: none; border-bottom: 3px solid transparent; color: #64748b; font-weight: 500; font-size: 15px; cursor: pointer; transition: all 0.2s;">
          âœ‚ï¸ å•æ®µåˆ†å‰²æµ‹è¯•
        </button>
      </div>
    </div>

    <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
    <div id="mainTabContent">
    <section class="panel">
      <h2>ğŸ“„ æ–‡ä»¶ä¸Šä¼ ä¸è§£æ</h2>
      <div class="controls">
        <div class="control-group primary">
          <input type="file" id="pdfFile" accept="application/pdf,application/epub+zip,.pdf,.epub" />
          <label class="checkbox-label">
            <input type="checkbox" id="translateBookCheckbox" />
            <span>æ˜¯å¦ç¿»è¯‘ä¹¦ç±</span>
          </label>
          <button id="loadFromDbButton" style="background: #8b5cf6; color: white;">ğŸ“š ä»æ•°æ®åº“åŠ è½½</button>
          <button id="cleanTocButton">æ­¥éª¤1: ç›®å½•æ¸…æ´—</button>
          <button id="extractButton" disabled>æ­¥éª¤2: è§£æå†…å®¹ä¸ç»Ÿè®¡</button>
          <button id="testTranslateButton" style="background: #10b981; color: white;">ğŸŒ æµ‹è¯•ç¿»è¯‘</button>
        </div>
      </div>
      <div class="status" id="statusArea"></div>
      
      <!-- æ·±åº¦è§£è¯»æç¤ºè¯é…ç½® -->
      <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #1e293b;">ğŸ”§ æ·±åº¦è§£è¯»æç¤ºè¯é…ç½®</h3>
          <div style="display: flex; gap: 8px;">
            <button id="togglePromptBtn" style="padding: 6px 12px; font-size: 12px; background: #64748b; color: white; border: none; border-radius: 6px; cursor: pointer;">å±•å¼€é…ç½®</button>
            <button id="savePromptBtn" style="padding: 6px 12px; font-size: 12px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; display: none;">ä¿å­˜</button>
            <button id="resetPromptBtn" style="padding: 6px 12px; font-size: 12px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer; display: none;">é‡ç½®</button>
          </div>
        </div>
        <div id="promptConfigArea" style="display: none;">
          <div style="margin-bottom: 12px;">
            <label style="display: block; margin-bottom: 8px; font-size: 14px; font-weight: 500; color: #475569;">æç¤ºè¯æ¨¡æ¿ï¼ˆå¯ä½¿ç”¨å ä½ç¬¦ï¼š{chapter_title} å’Œ {chapter_fulltext}ï¼‰</label>
            <textarea id="interpretationPromptText" rows="12" style="width: 100%; padding: 12px; border: 1.5px solid #cbd5e1; border-radius: 8px; font-size: 13px; font-family: monospace; line-height: 1.6; resize: vertical;"></textarea>
            <div style="margin-top: 8px; font-size: 12px; color: #64748b;">
              <strong>å ä½ç¬¦è¯´æ˜ï¼š</strong><br>
              â€¢ <code>{chapter_title}</code> - ä¼šè¢«æ›¿æ¢ä¸ºç« èŠ‚æ ‡é¢˜<br>
              â€¢ <code>{chapter_fulltext}</code> - ä¼šè¢«æ›¿æ¢ä¸ºç« èŠ‚å®Œæ•´å†…å®¹
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 12px;">
        <h2 style="margin: 0;">ğŸ“Š è§£æç»“æœ</h2>
        <div style="display: flex; gap: 12px; flex-wrap: wrap; align-items: center;">
          <button id="tocSummaryButton" class="secondary" disabled style="font-size: 15px; padding: 12px 24px; background: #6366f1; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
            ğŸ“‹ ç›®å½•ä¸æ‘˜è¦è¯»å–
          </button>
          <label style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #475569;">
            <span>é‡æ„å­—æ•°ä¸Šé™ï¼š</span>
            <input type="number" id="restructureMaxLength" value="5000" min="100" max="50000" step="100" 
                   style="width: 100px; padding: 6px 10px; border: 1.5px solid #cbd5e1; border-radius: 6px; font-size: 14px;" />
            <span style="color: #94a3b8;">å­—</span>
          </label>
          <button id="restructureButton" class="secondary" disabled style="font-size: 15px; padding: 12px 24px; background: #8b5cf6; color: white;">
            ğŸ”„ æ–‡ç« ç»“æ„é‡æ„
          </button>
          <button id="ingestButton" class="secondary" disabled style="font-size: 15px; padding: 12px 24px;">
            ğŸ“ åŸºæœ¬ä¿¡æ¯å…¥åº“
          </button>
        </div>
      </div>
      <div id="progressWrapper" class="progress-wrapper">
        <div id="progressLabel" class="progress-label">å‡†å¤‡ä¸­...</div>
        <div class="progress-bar">
          <div id="progressFill" class="progress-fill"></div>
        </div>
      </div>
      <table>
        <thead>
          <tr>
            <th>ç›®å½•æ ‡é¢˜</th>
            <th>æŠ½å–å†…å®¹</th>
            <th>ç»Ÿè®¡å­—æ•°</th>
            <th>ç¿»è¯‘</th>
            <th>ç« èŠ‚æ¦‚è¿°</th>
            <th>é‡æ„</th>
          </tr>
        </thead>
        <tbody id="resultsBody">
          <tr>
            <td colspan="6" style="text-align: center; color: #94a3b8; padding: 40px;">
              ç­‰å¾…è§£æç»“æœ...
            </td>
          </tr>
        </tbody>
      </table>
      <div id="tocSummaryResult" style="display: none; margin-top: 20px; padding: 16px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <h3 style="margin: 0; color: #1e293b; font-size: 16px;">ğŸ“‹ ç›®å½•ä¸æ‘˜è¦</h3>
          <button id="copyTocSummaryButton" class="secondary" style="padding: 6px 12px; font-size: 12px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer;">ğŸ“‹ å¤åˆ¶æ–‡æœ¬</button>
        </div>
        <textarea id="tocSummaryText" readonly style="width: 100%; min-height: 300px; padding: 12px; border: 1px solid #e2e8f0; border-radius: 6px; font-family: 'Monaco', 'Menlo', monospace; font-size: 13px; line-height: 1.6; background: #ffffff; resize: vertical;"></textarea>
      </div>
    </section>
    </div>
    <!-- å•æ®µåˆ†å‰²æµ‹è¯•Tabå†…å®¹ -->
    <div id="splitTestTabContent" style="display: none;">
      <section class="panel">
        <h2>âœ‚ï¸ å•æ®µæ–‡ç« åˆ†å‰²æµ‹è¯•</h2>
        <p style="color: #64748b; margin-bottom: 24px; font-size: 14px;">
          ç²˜è´´ä»»æ„é•¿åº¦çš„æ–‡ç« ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨åˆ†å‰²å¹¶ç”Ÿæˆæ–°æ ‡é¢˜ã€‚ç”¨äºæµ‹è¯•åˆ†å‰²å’Œæ ‡é¢˜ç”ŸæˆåŠŸèƒ½çš„ç¨³å®šæ€§ã€‚
        </p>
        
        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #1e293b;">æ–‡ç« æ ‡é¢˜ï¼ˆå¯é€‰ï¼‰</label>
          <input type="text" id="splitTestTitle" placeholder="è¾“å…¥æ–‡ç« æ ‡é¢˜ï¼Œå¦‚æœä¸å¡«å†™å°†è‡ªåŠ¨ç”Ÿæˆ..." 
                 style="width: 100%; padding: 10px 14px; border: 1.5px solid #cbd5e1; border-radius: 8px; font-size: 14px;" />
        </div>
        
        <div style="margin-bottom: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <label style="font-weight: 600; color: #1e293b;">æ–‡ç« å†…å®¹</label>
            <div style="display: flex; gap: 12px; align-items: center;">
              <label style="font-size: 13px; color: #64748b; display: flex; align-items: center; gap: 6px;">
                æœ€å¤§å­—æ•°ï¼š
                <input type="number" id="splitTestMaxWords" value="10000" min="1000" max="50000" step="1000"
                       style="width: 100px; padding: 6px 8px; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 13px;" />
              </label>
              <button id="clearSplitTestBtn" style="padding: 6px 12px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">
                æ¸…ç©º
              </button>
            </div>
          </div>
          <textarea id="splitTestContent" rows="20" placeholder="ç²˜è´´æˆ–è¾“å…¥è¦åˆ†å‰²çš„æ–‡ç« å†…å®¹..." 
                    style="width: 100%; padding: 12px; border: 1.5px solid #cbd5e1; border-radius: 8px; font-size: 14px; font-family: inherit; resize: vertical; line-height: 1.6;"></textarea>
          <div style="margin-top: 8px; font-size: 12px; color: #64748b;">
            å½“å‰å­—æ•°ï¼š<span id="splitTestWordCount">0</span> å­—ï¼ˆå»é™¤ç©ºæ ¼åï¼‰
          </div>
        </div>
        
        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
          <button id="splitTestButton" style="padding: 12px 24px; background: #8b5cf6; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; flex: 1;">
            ğŸ”„ å¼€å§‹åˆ†å‰²
          </button>
        </div>
        
        <div class="status" id="splitTestStatus" style="display: none;"></div>
        
        <div id="splitTestResult" style="display: none; margin-top: 24px;">
          <h3 style="margin: 0 0 16px 0; font-size: 18px; font-weight: 600; color: #1e293b;">åˆ†å‰²ç»“æœ</h3>
          <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 0; border: 1px solid #e2e8f0; border-radius: 8px; overflow: hidden;">
            <div style="padding: 20px; border-right: 1px solid #e2e8f0; background: #f8fafc; max-height: 600px; overflow-y: auto;">
              <h4 style="margin: 0 0 16px 0; font-size: 14px; font-weight: 600; color: #475569;">ğŸ“‘ åˆ†å‰²åçš„æ ‡é¢˜åˆ—è¡¨</h4>
              <div id="splitTestToc" style="font-size: 13px; line-height: 1.8;"></div>
            </div>
            <div style="padding: 20px; background: #ffffff; max-height: 600px; overflow-y: auto;">
              <h4 style="margin: 0 0 16px 0; font-size: 14px; font-weight: 600; color: #475569;">ğŸ“„ é€‰ä¸­éƒ¨åˆ†å†…å®¹</h4>
              <div id="splitTestContentDisplay" style="font-size: 14px; line-height: 1.8; white-space: pre-wrap; color: #334155;"></div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <dialog id="contentDialog">
      <h3 id="dialogTitle"></h3>
      <div class="modal-body" id="dialogContent"></div>
      <div style="text-align: right">
        <button id="closeDialog">å…³é—­</button>
      </div>
    </dialog>

    <dialog id="tocCompareDialog" style="max-width: 90vw; width: 1200px; padding: 0; border-radius: 12px;">
      <div style="padding: 24px; border-bottom: 1px solid #e2e8f0;">
        <h3 style="margin: 0; font-size: 20px; font-weight: 600;">ç›®å½•æ¸…æ´—å¯¹æ¯”</h3>
      </div>
      <div style="padding: 24px; display: grid; grid-template-columns: 1fr 1fr; gap: 24px; max-height: 70vh; overflow-y: auto;">
        <div>
          <h4 style="margin: 0 0 16px 0; color: #64748b; font-size: 14px; font-weight: 600;">æ¸…æ´—å‰ (å…± <span id="rawCount">0</span> é¡¹)</h4>
          <div id="rawTocList" style="background: #f8fafc; padding: 16px; border-radius: 8px; font-size: 13px; line-height: 1.8; max-height: 60vh; overflow-y: auto;"></div>
        </div>
        <div>
          <h4 style="margin: 0 0 16px 0; color: #10b981; font-size: 14px; font-weight: 600;">æ¸…æ´—å (å…± <span id="cleanedCount">0</span> é¡¹)</h4>
          <div id="cleanedTocList" style="background: #f0fdf4; padding: 16px; border-radius: 8px; font-size: 13px; line-height: 1.8; max-height: 60vh; overflow-y: auto;"></div>
        </div>
      </div>
      <div style="padding: 16px 24px; border-top: 1px solid #e2e8f0; text-align: right;">
        <button id="closeTocDialog" style="padding: 10px 20px; border-radius: 8px; border: none; background: #2563eb; color: white; cursor: pointer;">å…³é—­</button>
      </div>
    </dialog>

    <dialog id="loadBookDialog" style="max-width: 90vw; width: 1000px; padding: 0; border-radius: 12px; max-height: 90vh;">
      <div style="padding: 24px; border-bottom: 1px solid #e2e8f0; background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%); color: white;">
        <h3 style="margin: 0; font-size: 20px; font-weight: 600;">ğŸ“š ä»æ•°æ®åº“åŠ è½½ä¹¦ç±</h3>
        <p style="margin: 8px 0 0 0; font-size: 14px; opacity: 0.9;">é€‰æ‹©å·²è§£æçš„ä¹¦ç±ï¼Œç›´æ¥åŠ è½½å…¶ç›®å½•å’Œå†…å®¹</p>
      </div>
      <div style="padding: 24px; max-height: calc(90vh - 140px); overflow-y: auto;">
        <div style="margin-bottom: 16px;">
          <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 12px;">
            <input type="text" id="bookSearchInput" placeholder="æœç´¢ä¹¦ç±åç§°..." style="flex: 1; padding: 8px 12px; border: 1.5px solid #cbd5e1; border-radius: 6px; font-size: 14px;" />
            <button id="refreshBooksBtn" style="padding: 8px 16px; background: #64748b; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">åˆ·æ–°</button>
          </div>
        </div>
        <div id="booksList" style="display: grid; gap: 12px;">
          <div style="text-align: center; padding: 40px; color: #94a3b8;">
            <span class="loading"></span> åŠ è½½ä¸­...
          </div>
        </div>
      </div>
      <div style="padding: 16px 24px; border-top: 1px solid #e2e8f0; text-align: right; background: #f8fafc;">
        <button id="closeLoadBookDialog" style="padding: 10px 20px; border-radius: 8px; border: none; background: #2563eb; color: white; cursor: pointer;">å…³é—­</button>
      </div>
    </dialog>

    <dialog id="restructureDialog" style="max-width: 95vw; width: 1400px; padding: 0; border-radius: 12px; max-height: 90vh;">
      <div style="padding: 24px; border-bottom: 1px solid #e2e8f0; background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%); color: white;">
        <h3 style="margin: 0; font-size: 20px; font-weight: 600;">ğŸ”„ æ–‡ç« ç»“æ„é‡æ„ç»“æœ</h3>
        <p style="margin: 8px 0 0 0; font-size: 14px; opacity: 0.9;">æ–°ç›®å½•ï¼ˆè‡ªåŠ¨åˆ†å‰²è¶…è¿‡1ä¸‡å­—çš„ç« èŠ‚ï¼‰</p>
      </div>
      <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 0; max-height: calc(90vh - 140px); overflow: hidden;">
        <div style="padding: 24px; border-right: 1px solid #e2e8f0; overflow-y: auto; background: #f8fafc;">
          <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #1e293b;">ğŸ“‘ æ–°ç›®å½•</h4>
          <div id="restructuredToc" style="font-size: 14px; line-height: 1.8;"></div>
        </div>
        <div style="padding: 24px; overflow-y: auto;">
          <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #1e293b;">ğŸ“„ ç« èŠ‚å†…å®¹</h4>
          <div id="restructuredContent" style="font-size: 14px; line-height: 1.8; white-space: pre-wrap; color: #334155;"></div>
        </div>
      </div>
      <div style="padding: 16px 24px; border-top: 1px solid #e2e8f0; text-align: right; background: #f8fafc;">
        <button id="closeRestructureDialog" style="padding: 10px 20px; border-radius: 8px; border: none; background: #2563eb; color: white; cursor: pointer;">å…³é—­</button>
      </div>
    </dialog>

    <dialog id="translateTestDialog" style="max-width: 90vw; width: 800px; padding: 0; border-radius: 12px;">
      <div style="padding: 24px; border-bottom: 1px solid #e2e8f0;">
        <h3 style="margin: 0; font-size: 20px; font-weight: 600;">ğŸŒ ç¿»è¯‘æµ‹è¯•</h3>
      </div>
      <div style="padding: 24px; max-height: 80vh; overflow-y: auto;">
        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 600;">è¾“å…¥è¦ç¿»è¯‘çš„æ–‡æœ¬ï¼ˆéä¸­æ–‡ï¼‰ï¼š</label>
          <textarea id="translateInput" style="width: 100%; min-height: 100px; padding: 12px; border: 1.5px solid #cbd5e1; border-radius: 8px; font-size: 14px; font-family: inherit;" placeholder="è¾“å…¥è‹±æ–‡æˆ–å…¶ä»–è¯­è¨€çš„æ–‡æœ¬..."></textarea>
        </div>
        <div>
          <label style="display: block; margin-bottom: 8px; font-weight: 600;">ç¿»è¯‘ç»“æœï¼ˆä¸­æ–‡ï¼‰ï¼š</label>
          <div id="translateOutput" style="width: 100%; min-height: 100px; padding: 12px; border: 1.5px solid #cbd5e1; border-radius: 8px; font-size: 14px; background: #f8fafc; white-space: pre-wrap; word-wrap: break-word;"></div>
        </div>
      </div>
      <div style="padding: 16px 24px; border-top: 1px solid #e2e8f0; display: flex; justify-content: space-between;">
        <button id="doTranslateButton" style="padding: 10px 20px; border-radius: 8px; border: none; background: #10b981; color: white; cursor: pointer;">ç¿»è¯‘</button>
        <button id="closeTranslateDialog" style="padding: 10px 20px; border-radius: 8px; border: none; background: #2563eb; color: white; cursor: pointer;">å…³é—­</button>
      </div>
    </dialog>

    <script>
      const cleanTocButton = document.getElementById("cleanTocButton");
      const extractButton = document.getElementById("extractButton");
      const testTranslateButton = document.getElementById("testTranslateButton");
      const pdfFile = document.getElementById("pdfFile");
      const ingestButton = document.getElementById("ingestButton");
      const statusArea = document.getElementById("statusArea");
      const resultsBody = document.getElementById("resultsBody");
      const dialog = document.getElementById("contentDialog");
      const dialogTitle = document.getElementById("dialogTitle");
      const dialogContent = document.getElementById("dialogContent");
      const closeDialog = document.getElementById("closeDialog");
      const tocCompareDialog = document.getElementById("tocCompareDialog");
      const closeTocDialog = document.getElementById("closeTocDialog");
      const translateTestDialog = document.getElementById("translateTestDialog");
      const closeTranslateDialog = document.getElementById("closeTranslateDialog");
      const doTranslateButton = document.getElementById("doTranslateButton");
      const translateInput = document.getElementById("translateInput");
      const translateOutput = document.getElementById("translateOutput");
      const rawTocList = document.getElementById("rawTocList");
      const cleanedTocList = document.getElementById("cleanedTocList");
      const rawCount = document.getElementById("rawCount");
      const cleanedCount = document.getElementById("cleanedCount");
      const progressWrapper = document.getElementById("progressWrapper");
      const progressLabel = document.getElementById("progressLabel");
      const progressFill = document.getElementById("progressFill");
      const translateBookCheckbox = document.getElementById("translateBookCheckbox");
      const togglePromptBtn = document.getElementById("togglePromptBtn");
      const savePromptBtn = document.getElementById("savePromptBtn");
      const resetPromptBtn = document.getElementById("resetPromptBtn");
      const promptConfigArea = document.getElementById("promptConfigArea");
      const interpretationPromptText = document.getElementById("interpretationPromptText");
      const restructureButton = document.getElementById("restructureButton");
      const restructureDialog = document.getElementById("restructureDialog");
      const closeRestructureDialog = document.getElementById("closeRestructureDialog");
      const restructuredToc = document.getElementById("restructuredToc");
      const restructuredContent = document.getElementById("restructuredContent");
      const loadFromDbButton = document.getElementById("loadFromDbButton");
      const loadBookDialog = document.getElementById("loadBookDialog");
      const closeLoadBookDialog = document.getElementById("closeLoadBookDialog");
      const booksList = document.getElementById("booksList");
      const bookSearchInput = document.getElementById("bookSearchInput");
      const refreshBooksBtn = document.getElementById("refreshBooksBtn");
      const mainTabBtn = document.getElementById("mainTabBtn");
      const splitTestTabBtn = document.getElementById("splitTestTabBtn");
      const mainTabContent = document.getElementById("mainTabContent");
      const splitTestTabContent = document.getElementById("splitTestTabContent");
      const splitTestTitle = document.getElementById("splitTestTitle");
      const splitTestContent = document.getElementById("splitTestContent");
      const splitTestMaxWords = document.getElementById("splitTestMaxWords");
      const splitTestWordCount = document.getElementById("splitTestWordCount");
      const splitTestButton = document.getElementById("splitTestButton");
      const splitTestStatus = document.getElementById("splitTestStatus");
      const splitTestResult = document.getElementById("splitTestResult");
      const splitTestToc = document.getElementById("splitTestToc");
      const splitTestContentDisplay = document.getElementById("splitTestContentDisplay");
      const clearSplitTestBtn = document.getElementById("clearSplitTestBtn");
      let parsedEntries = [];
      let currentFilename = "";
      let cleanedTocData = null;
      let currentFileType = null;
      let restructuredEntries = [];
      let selectedRestructureIndex = -1;
      let allBooks = [];
      let splitTestResults = [];
      
      // é»˜è®¤çš„æ·±åº¦è§£è¯»æç¤ºè¯
      const defaultInterpretationPrompt = `è¯·å¯¹ä»¥ä¸‹ç« èŠ‚å†…å®¹è¿›è¡Œæ·±åº¦è§£è¯»å’Œåˆ†æï¼š

ã€ç« èŠ‚æ ‡é¢˜ã€‘
{chapter_title}

ã€ç« èŠ‚å†…å®¹ã€‘
{chapter_fulltext}

è¯·ä»ä»¥ä¸‹è§’åº¦è¿›è¡Œè§£è¯»ï¼š
1. æ ¸å¿ƒè§‚ç‚¹å’Œä¸»è¦è®ºç‚¹
2. ä½œè€…çš„è®ºè¯é€»è¾‘å’Œæ¨ç†è¿‡ç¨‹
3. å…³é”®æ¦‚å¿µçš„è§£é‡Šå’Œå»¶ä¼¸
4. å®é™…åº”ç”¨ä»·å€¼å’Œå¯ç¤º
5. ä¸å…¶ä»–çŸ¥è¯†ç‚¹çš„å…³è”

è¯·ç”¨æ¸…æ™°ã€æ˜“æ‡‚çš„æ–¹å¼å‘ˆç°è§£è¯»ç»“æœã€‚`;
      
      // åŠ è½½ä¿å­˜çš„æç¤ºè¯
      function loadInterpretationPrompt() {
        const saved = localStorage.getItem("interpretationPrompt");
        if (saved) {
          interpretationPromptText.value = saved;
        } else {
          interpretationPromptText.value = defaultInterpretationPrompt;
        }
      }
      
      // ä¿å­˜æç¤ºè¯
      function saveInterpretationPrompt() {
        const prompt = interpretationPromptText.value.trim();
        if (prompt) {
          localStorage.setItem("interpretationPrompt", prompt);
          renderStatus("æç¤ºè¯å·²ä¿å­˜", "success");
          savePromptBtn.style.display = "none";
        } else {
          renderStatus("æç¤ºè¯ä¸èƒ½ä¸ºç©º", "error");
        }
      }
      
      // é‡ç½®æç¤ºè¯
      function resetInterpretationPrompt() {
        if (confirm("ç¡®å®šè¦é‡ç½®ä¸ºé»˜è®¤æç¤ºè¯å—ï¼Ÿ")) {
          interpretationPromptText.value = defaultInterpretationPrompt;
          localStorage.removeItem("interpretationPrompt");
          renderStatus("å·²é‡ç½®ä¸ºé»˜è®¤æç¤ºè¯", "success");
          savePromptBtn.style.display = "block";
        }
      }
      
      // è·å–å½“å‰ä½¿ç”¨çš„æç¤ºè¯
      function getInterpretationPrompt() {
        const saved = localStorage.getItem("interpretationPrompt");
        return saved || defaultInterpretationPrompt;
      }
      
      // åˆ‡æ¢é…ç½®åŒºåŸŸæ˜¾ç¤º
      togglePromptBtn.addEventListener("click", () => {
        const isVisible = promptConfigArea.style.display !== "none";
        promptConfigArea.style.display = isVisible ? "none" : "block";
        togglePromptBtn.textContent = isVisible ? "å±•å¼€é…ç½®" : "æ”¶èµ·é…ç½®";
        savePromptBtn.style.display = isVisible ? "none" : "block";
        resetPromptBtn.style.display = isVisible ? "none" : "block";
        
        if (!isVisible) {
          loadInterpretationPrompt();
        }
      });
      
      // ä¿å­˜æŒ‰é’®
      savePromptBtn.addEventListener("click", saveInterpretationPrompt);
      
      // é‡ç½®æŒ‰é’®
      resetPromptBtn.addEventListener("click", resetInterpretationPrompt);
      
      // ç›‘å¬æç¤ºè¯å˜åŒ–
      interpretationPromptText.addEventListener("input", () => {
        savePromptBtn.style.display = "block";
      });
      
      // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
      loadInterpretationPrompt();

      /**
       * ä½¿ç”¨æ·±åº¦æ€è€ƒæ¨¡å‹è¿›è¡Œå†…å®¹è§£è¯»
       * @param {string} content - è¦è§£è¯»çš„å†…å®¹ï¼ˆå¦‚ç« èŠ‚æ­£æ–‡ï¼‰
       * @param {string} prompt - è§£è¯»æç¤ºè¯ï¼ˆå¯åŒ…å«å ä½ç¬¦å¦‚ {chapter_fulltext}ï¼‰
       * @param {Object} options - å¯é€‰å‚æ•°
       * @param {string} options.model - æ¨¡å‹åç§°ï¼Œé»˜è®¤ 'doubao-seed-1-6-251015'
       * @param {number} options.temperature - æ¸©åº¦å‚æ•°ï¼Œé»˜è®¤ 0.3
       * @param {number} options.max_tokens - æœ€å¤§tokenæ•°ï¼Œé»˜è®¤ 16000
       * @param {number} options.timeout - è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œé»˜è®¤ 300000 (5åˆ†é’Ÿ)
       * @param {Object} options.replacements - å ä½ç¬¦æ›¿æ¢å¯¹è±¡ï¼Œå¦‚ {chapter_fulltext: '...', chapter_title: '...'}
       * @returns {Promise<Object>} è¿”å› {reasoning_content: string, content: string} æˆ–æŠ›å‡ºé”™è¯¯
       */
      async function interpretWithDeepThinking(content, prompt, options = {}) {
        const {
          model = 'doubao-seed-1-6-251015',
          temperature = 0.3,
          max_tokens = 16000,
          timeout = 300000,
          replacements = {}
        } = options;

        // æ„å»ºå®Œæ•´çš„ promptï¼šæ›¿æ¢å ä½ç¬¦
        let finalPrompt = prompt;
        
        // é»˜è®¤æ›¿æ¢ {chapter_fulltext} ä¸ºå†…å®¹
        if (content && !replacements.chapter_fulltext) {
          replacements.chapter_fulltext = content;
        }
        
        // æ‰§è¡Œæ‰€æœ‰å ä½ç¬¦æ›¿æ¢
        for (const [placeholder, value] of Object.entries(replacements)) {
          const regex = new RegExp(`{${placeholder}}`, 'g');
          finalPrompt = finalPrompt.replace(regex, value || '');
        }

        try {
          // åˆ›å»º AbortController ç”¨äºè¶…æ—¶æ§åˆ¶
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          // è°ƒç”¨æ·±åº¦æ€è€ƒæ¥å£
          let response;
          try {
            response = await fetch("/api/test/doubao-thinking", {
              method: "POST",
              headers: { 
                "Content-Type": "application/json",
                "Accept": "application/json"
              },
              body: JSON.stringify({
                prompt: finalPrompt,
                temperature: temperature,
                max_tokens: max_tokens,
                model: model,
              }),
              signal: controller.signal,
            });
          } catch (fetchError) {
            clearTimeout(timeoutId);
            if (fetchError.name === "AbortError") {
              throw new Error("è¯·æ±‚è¶…æ—¶ï¼ˆè¶…è¿‡5åˆ†é’Ÿï¼‰ï¼Œè¯·ç¨åé‡è¯•");
            }
            // æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
            const errorMsg = fetchError.message || String(fetchError);
            if (errorMsg.includes("Failed to fetch") || errorMsg.includes("NetworkError")) {
              throw new Error("æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ï¼š\n1. æœåŠ¡å™¨æ˜¯å¦æ­£åœ¨è¿è¡Œï¼ˆç«¯å£5001ï¼‰\n2. é¡µé¢æ˜¯å¦é€šè¿‡ http://localhost:5001/parser_test_page.html è®¿é—®\n3. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸");
            }
            throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${errorMsg}`);
          }
          clearTimeout(timeoutId);

          if (!response.ok) {
            let errorMessage = "ç”Ÿæˆå¤±è´¥";
            try {
              const errorText = await response.text();
              try {
                const errorData = JSON.parse(errorText);
                errorMessage = errorData.error || errorMessage;
              } catch (e) {
                errorMessage = errorText || errorMessage;
              }
            } catch (e) {
              errorMessage = `HTTP ${response.status}: ${response.statusText}`;
            }
            throw new Error(errorMessage);
          }

          const data = await response.json();
          
          // è¿”å›ç»“æ„åŒ–çš„ç»“æœ
          return {
            reasoning_content: data.reasoning_content || null,
            content: data.content || null,
            success: true
          };

        } catch (error) {
          // ç»Ÿä¸€é”™è¯¯å¤„ç†
          let errorMessage = "è§£è¯»å¤±è´¥";
          if (error.name === "AbortError" || error.name === "TimeoutError") {
            errorMessage = "è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•";
          } else if (error.message) {
            errorMessage = error.message;
          } else if (error instanceof TypeError && error.message.includes("fetch")) {
            errorMessage = "ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦è¿è¡Œ";
          }
          
          throw new Error(errorMessage);
        }
      }

      closeDialog.addEventListener("click", () => dialog.close());
      closeTocDialog.addEventListener("click", () => tocCompareDialog.close());
      closeTranslateDialog.addEventListener("click", () => translateTestDialog.close());
      closeRestructureDialog.addEventListener("click", () => restructureDialog.close());
      closeLoadBookDialog.addEventListener("click", () => loadBookDialog.close());
      
      // Tab åˆ‡æ¢åŠŸèƒ½
      mainTabBtn.addEventListener("click", () => {
        switchTab("main");
      });
      
      splitTestTabBtn.addEventListener("click", () => {
        switchTab("splitTest");
      });
      
      function switchTab(tabName) {
        if (tabName === "main") {
          mainTabContent.style.display = "block";
          splitTestTabContent.style.display = "none";
          mainTabBtn.classList.add("active");
          splitTestTabBtn.classList.remove("active");
          mainTabBtn.style.borderBottomColor = "#2563eb";
          mainTabBtn.style.color = "#2563eb";
          mainTabBtn.style.fontWeight = "600";
          splitTestTabBtn.style.borderBottomColor = "transparent";
          splitTestTabBtn.style.color = "#64748b";
          splitTestTabBtn.style.fontWeight = "500";
        } else {
          mainTabContent.style.display = "none";
          splitTestTabContent.style.display = "block";
          splitTestTabBtn.classList.add("active");
          mainTabBtn.classList.remove("active");
          splitTestTabBtn.style.borderBottomColor = "#2563eb";
          splitTestTabBtn.style.color = "#2563eb";
          splitTestTabBtn.style.fontWeight = "600";
          mainTabBtn.style.borderBottomColor = "transparent";
          mainTabBtn.style.color = "#64748b";
          mainTabBtn.style.fontWeight = "500";
        }
      }
      
      // å•æ®µåˆ†å‰²æµ‹è¯•åŠŸèƒ½
      // å­—æ•°ç»Ÿè®¡
      splitTestContent.addEventListener("input", () => {
        const wordCount = calculateWordCount(splitTestContent.value);
        splitTestWordCount.textContent = wordCount.toLocaleString();
      });
      
      // æ¸…ç©ºæŒ‰é’®
      clearSplitTestBtn.addEventListener("click", () => {
        splitTestTitle.value = "";
        splitTestContent.value = "";
        splitTestWordCount.textContent = "0";
        splitTestResult.style.display = "none";
        splitTestStatus.style.display = "none";
      });
      
      /**
       * æ–‡ç« åˆ†å‰²å‡½æ•°
       * @param {string} content - è¦åˆ†å‰²çš„æ–‡ç« å†…å®¹
       * @param {number} maxWordCount - æ¯ä¸ªæ®µè½çš„æœ€å¤§å­—æ•°è¦æ±‚ï¼ˆå»é™¤ç©ºæ ¼åï¼‰
       * @param {string} [title="æœªå‘½åæ–‡ç« "] - æ–‡ç« æ ‡é¢˜ï¼ˆå¯é€‰ï¼‰
       * @returns {Promise<Array<{title: string, content: string, word_count: number}>>} è¿”å›æ®µè½æ•°ç»„ï¼Œæ¯ä¸ªæ®µè½åŒ…å«æ ‡é¢˜ã€å†…å®¹å’Œå­—æ•°
       * @throws {Error} å¦‚æœåˆ†å‰²å¤±è´¥ä¼šæŠ›å‡ºé”™è¯¯
       */
      async function splitArticleIntoSegments(content, maxWordCount, title = "æœªå‘½åæ–‡ç« ") {
        // å‚æ•°éªŒè¯
        if (!content || !content.trim()) {
          throw new Error("æ–‡ç« å†…å®¹ä¸èƒ½ä¸ºç©º");
        }
        
        const actualMaxWordCount = parseInt(maxWordCount) || 10000;
        if (actualMaxWordCount <= 0) {
          throw new Error("å­—æ•°è¦æ±‚å¿…é¡»å¤§äº0");
        }
        
        // è®¡ç®—åŸå§‹å­—æ•°
        const calculateWordCount = (text) => {
          if (!text) return 0;
          return text.replace(/\s+/g, "").length;
        };
        
        const originalWordCount = calculateWordCount(content);
        if (originalWordCount === 0) {
          throw new Error("æ–‡ç« å†…å®¹ä¸ºç©º");
        }
        
        // åˆ›å»º AbortController ç”¨äºè¶…æ—¶æ§åˆ¶
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 600000); // 10åˆ†é’Ÿè¶…æ—¶
        
        try {
          const response = await fetch("/api/restructure/split-chapter", {
            method: "POST",
            headers: { 
              "Content-Type": "application/json",
              "Accept": "application/json"
            },
            body: JSON.stringify({
              title: title || "æœªå‘½åæ–‡ç« ",
              content: content.trim(),
              max_word_count: actualMaxWordCount,
              word_count: originalWordCount
            }),
            signal: controller.signal,
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            let errorMessage = `åˆ†å‰²å¤±è´¥ (çŠ¶æ€ç : ${response.status})`;
            try {
              const errorText = await response.text();
              try {
                const errorData = JSON.parse(errorText);
                errorMessage = errorData.error || errorMessage;
              } catch (e) {
                errorMessage = errorText || errorMessage;
              }
            } catch (e) {
              // å¦‚æœæ— æ³•è¯»å–å“åº”ï¼Œä½¿ç”¨é»˜è®¤é”™è¯¯æ¶ˆæ¯
            }
            throw new Error(errorMessage);
          }
          
          let splitResult;
          try {
            splitResult = await response.json();
          } catch (jsonError) {
            throw new Error(`æœåŠ¡å™¨å“åº”æ ¼å¼é”™è¯¯: ${jsonError.message}`);
          }
          
          const segments = splitResult.segments || [];
          
          if (segments.length === 0) {
            throw new Error("åˆ†å‰²å¤±è´¥ï¼Œæœªç”Ÿæˆä»»ä½•ç‰‡æ®µ");
          }
          
          // æ ¼å¼åŒ–è¿”å›ç»“æœï¼Œç¡®ä¿æ¯ä¸ªæ®µè½éƒ½æœ‰æ­£ç¡®çš„å­—æ•°
          return segments.map((segment, index) => ({
            title: segment.title || `ç¬¬${index + 1}éƒ¨åˆ†`,
            content: segment.content || "",
            word_count: segment.word_count || calculateWordCount(segment.content || "")
          }));
          
        } catch (fetchError) {
          clearTimeout(timeoutId);
          if (fetchError.name === "AbortError") {
            throw new Error("è¯·æ±‚è¶…æ—¶ï¼ˆè¶…è¿‡10åˆ†é’Ÿï¼‰ï¼Œè¯·ç¨åé‡è¯•æˆ–å‡å°‘æ–‡ç« é•¿åº¦");
          }
          // æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
          const errorMsg = fetchError.message || String(fetchError);
          if (errorMsg.includes("Failed to fetch") || errorMsg.includes("NetworkError")) {
            throw new Error("æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ï¼š\n1. æœåŠ¡å™¨æ˜¯å¦æ­£åœ¨è¿è¡Œï¼ˆç«¯å£5001ï¼‰\n2. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸\n3. æµè§ˆå™¨æ§åˆ¶å°æ˜¯å¦æœ‰æ›´å¤šé”™è¯¯ä¿¡æ¯");
          }
          throw fetchError;
        }
      }

      /**
       * æµ‹è¯•æ–‡ç« åˆ†å‰²å‡½æ•°
       * å¯åœ¨æµè§ˆå™¨æ§åˆ¶å°è°ƒç”¨ï¼štestSplitArticleFunction()
       */
      async function testSplitArticleFunction() {
        console.log("ğŸ§ª å¼€å§‹æµ‹è¯• splitArticleIntoSegments å‡½æ•°...");
        
        // æµ‹è¯•æ•°æ®ï¼šä¸€ç¯‡è¾ƒé•¿çš„ç¤ºä¾‹æ–‡ç« 
        const testContent = `
äººå·¥æ™ºèƒ½ï¼ˆArtificial Intelligenceï¼ŒAIï¼‰æ˜¯è®¡ç®—æœºç§‘å­¦çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œè‡´åŠ›äºåˆ›å»ºèƒ½å¤Ÿæ‰§è¡Œé€šå¸¸éœ€è¦äººç±»æ™ºèƒ½çš„ä»»åŠ¡çš„ç³»ç»Ÿã€‚

æœºå™¨å­¦ä¹ æ˜¯äººå·¥æ™ºèƒ½çš„æ ¸å¿ƒæŠ€æœ¯ä¹‹ä¸€ã€‚å®ƒä½¿è®¡ç®—æœºèƒ½å¤Ÿåœ¨æ²¡æœ‰æ˜ç¡®ç¼–ç¨‹çš„æƒ…å†µä¸‹å­¦ä¹ å’Œæ”¹è¿›ã€‚æœºå™¨å­¦ä¹ ç®—æ³•é€šè¿‡åˆ†æå¤§é‡æ•°æ®æ¥è¯†åˆ«æ¨¡å¼å¹¶åšå‡ºé¢„æµ‹æˆ–å†³ç­–ã€‚

æ·±åº¦å­¦ä¹ æ˜¯æœºå™¨å­¦ä¹ çš„ä¸€ä¸ªå­é›†ï¼Œå®ƒä½¿ç”¨äººå·¥ç¥ç»ç½‘ç»œæ¥æ¨¡æ‹Ÿäººè„‘çš„å·¥ä½œæ–¹å¼ã€‚æ·±åº¦ç¥ç»ç½‘ç»œç”±å¤šä¸ªå±‚ç»„æˆï¼Œæ¯ä¸€å±‚éƒ½èƒ½å¤Ÿä»è¾“å…¥æ•°æ®ä¸­æå–æ›´å¤æ‚çš„ç‰¹å¾ã€‚

è‡ªç„¶è¯­è¨€å¤„ç†ï¼ˆNLPï¼‰æ˜¯äººå·¥æ™ºèƒ½çš„å¦ä¸€ä¸ªé‡è¦é¢†åŸŸã€‚å®ƒä½¿è®¡ç®—æœºèƒ½å¤Ÿç†è§£ã€è§£é‡Šå’Œç”Ÿæˆäººç±»è¯­è¨€ã€‚ä»ç®€å•çš„æ–‡æœ¬åˆ†ç±»åˆ°å¤æ‚çš„å¯¹è¯ç³»ç»Ÿï¼ŒNLPæŠ€æœ¯åœ¨å„ä¸ªé¢†åŸŸéƒ½æœ‰å¹¿æ³›çš„åº”ç”¨ã€‚

è®¡ç®—æœºè§†è§‰ä½¿æœºå™¨èƒ½å¤Ÿç†è§£å’Œè§£é‡Šè§†è§‰ä¿¡æ¯ã€‚é€šè¿‡å›¾åƒè¯†åˆ«ã€ç‰©ä½“æ£€æµ‹å’Œå›¾åƒåˆ†å‰²ç­‰æŠ€æœ¯ï¼Œè®¡ç®—æœºè§†è§‰ç³»ç»Ÿå¯ä»¥"çœ‹åˆ°"å¹¶ç†è§£å‘¨å›´çš„ä¸–ç•Œã€‚

å¼ºåŒ–å­¦ä¹ æ˜¯ä¸€ç§æœºå™¨å­¦ä¹ æ–¹æ³•ï¼Œå…¶ä¸­æ™ºèƒ½ä½“é€šè¿‡ä¸ç¯å¢ƒäº¤äº’æ¥å­¦ä¹ æœ€ä¼˜è¡Œä¸ºã€‚æ™ºèƒ½ä½“é€šè¿‡è¯•é”™æ¥å­¦ä¹ ï¼Œåœ¨æˆåŠŸçš„è¡Œä¸ºä¸Šè·å¾—å¥–åŠ±ï¼Œåœ¨å¤±è´¥çš„è¡Œä¸ºä¸Šå—åˆ°æƒ©ç½šã€‚

äººå·¥æ™ºèƒ½åœ¨å„ä¸ªè¡Œä¸šéƒ½æœ‰åº”ç”¨ã€‚åœ¨åŒ»ç–—é¢†åŸŸï¼ŒAIå¯ä»¥å¸®åŠ©è¯Šæ–­ç–¾ç—…ã€å‘ç°æ–°è¯ç‰©å’Œä¸ªæ€§åŒ–æ²»ç–—æ–¹æ¡ˆã€‚åœ¨é‡‘èé¢†åŸŸï¼ŒAIç”¨äºæ¬ºè¯ˆæ£€æµ‹ã€ç®—æ³•äº¤æ˜“å’Œé£é™©è¯„ä¼°ã€‚

è‡ªåŠ¨é©¾é©¶æ±½è½¦æ˜¯AIåœ¨äº¤é€šè¿è¾“é¢†åŸŸçš„å…¸å‹åº”ç”¨ã€‚è¿™äº›è½¦è¾†ä½¿ç”¨å„ç§ä¼ æ„Ÿå™¨å’ŒAIç®—æ³•æ¥æ„ŸçŸ¥å‘¨å›´ç¯å¢ƒã€åšå‡ºå†³ç­–å¹¶æ§åˆ¶è½¦è¾†ã€‚

åœ¨é›¶å”®å’Œç”µå­å•†åŠ¡é¢†åŸŸï¼ŒAIé©±åŠ¨çš„æ¨èç³»ç»Ÿå¸®åŠ©ç”¨æˆ·å‘ç°ä»–ä»¬å¯èƒ½æ„Ÿå…´è¶£çš„äº§å“ã€‚è¿™äº›ç³»ç»Ÿåˆ†æç”¨æˆ·çš„è¡Œä¸ºå’Œåå¥½ï¼Œæä¾›ä¸ªæ€§åŒ–çš„è´­ç‰©ä½“éªŒã€‚

äººå·¥æ™ºèƒ½çš„å‘å±•ä¹Ÿå¸¦æ¥äº†ä¼¦ç†å’Œç¤¾ä¼šé—®é¢˜ã€‚å°±ä¸šè‡ªåŠ¨åŒ–ã€éšç§é—®é¢˜ã€ç®—æ³•åè§å’ŒAIå®‰å…¨æ˜¯éœ€è¦è®¤çœŸè€ƒè™‘çš„é‡è¦è®®é¢˜ã€‚

å°½ç®¡é¢ä¸´æŒ‘æˆ˜ï¼Œäººå·¥æ™ºèƒ½çš„æ½œåŠ›æ˜¯å·¨å¤§çš„ã€‚éšç€æŠ€æœ¯çš„ä¸æ–­è¿›æ­¥ï¼Œæˆ‘ä»¬å¯ä»¥æœŸå¾…AIåœ¨æœªæ¥å¸¦æ¥æ›´å¤šåˆ›æ–°å’Œå˜é©ã€‚è¿™éœ€è¦æˆ‘ä»¬ç»§ç»­ç ”ç©¶å’Œå¼€å‘ï¼ŒåŒæ—¶ä¹Ÿè¦ç¡®ä¿AIçš„å‘å±•æ˜¯è´Ÿè´£ä»»å’Œæœ‰ç›Šçš„ã€‚
        `.trim();

        const testCases = [
          {
            name: "æµ‹è¯•1ï¼šæ ‡å‡†åˆ†å‰²ï¼ˆ5000å­—é™åˆ¶ï¼‰",
            content: testContent,
            maxWordCount: 5000,
            title: "äººå·¥æ™ºèƒ½æ¦‚è¿°"
          },
          {
            name: "æµ‹è¯•2ï¼šè¾ƒå¤§å­—æ•°é™åˆ¶ï¼ˆ15000å­—ï¼‰",
            content: testContent,
            maxWordCount: 15000,
            title: "äººå·¥æ™ºèƒ½æ¦‚è¿°"
          },
          {
            name: "æµ‹è¯•3ï¼šå°å­—æ•°é™åˆ¶ï¼ˆ1000å­—ï¼‰",
            content: testContent,
            maxWordCount: 1000,
            title: "äººå·¥æ™ºèƒ½æ¦‚è¿°"
          }
        ];

        const results = [];

        for (const testCase of testCases) {
          console.log(`\nğŸ“ ${testCase.name}`);
          console.log(`   è¾“å…¥å­—æ•°ï¼š${testCase.content.replace(/\s+/g, "").length} å­—`);
          console.log(`   å­—æ•°é™åˆ¶ï¼š${testCase.maxWordCount} å­—`);
          
          try {
            const startTime = Date.now();
            const segments = await splitArticleIntoSegments(
              testCase.content,
              testCase.maxWordCount,
              testCase.title
            );
            const endTime = Date.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);

            console.log(`   âœ… æˆåŠŸï¼è€—æ—¶ï¼š${duration} ç§’`);
            console.log(`   åˆ†å‰²ç»“æœï¼š${segments.length} æ®µ`);
            
            let totalWordCount = 0;
            segments.forEach((seg, idx) => {
              console.log(`   æ®µ ${idx + 1}ï¼š${seg.title} (${seg.word_count} å­—)`);
              totalWordCount += seg.word_count;
              
              // éªŒè¯æ¯æ®µå­—æ•°ä¸è¶…è¿‡é™åˆ¶
              if (seg.word_count > testCase.maxWordCount) {
                console.warn(`   âš ï¸  è­¦å‘Šï¼šæ®µ ${idx + 1} å­—æ•° (${seg.word_count}) è¶…è¿‡é™åˆ¶ (${testCase.maxWordCount})`);
              }
            });
            
            console.log(`   æ€»å­—æ•°ï¼š${totalWordCount} å­—`);

            results.push({
              name: testCase.name,
              success: true,
              segments: segments,
              duration: duration,
              segmentCount: segments.length,
              totalWordCount: totalWordCount
            });
          } catch (error) {
            console.error(`   âŒ å¤±è´¥ï¼š${error.message}`);
            results.push({
              name: testCase.name,
              success: false,
              error: error.message
            });
          }
        }

        // æµ‹è¯•é”™è¯¯å¤„ç†
        console.log("\nğŸ” æµ‹è¯•é”™è¯¯å¤„ç†...");
        
        try {
          await splitArticleIntoSegments("", 10000);
          console.error("   âŒ åº”è¯¥æŠ›å‡ºé”™è¯¯ï¼Œä½†æ²¡æœ‰æŠ›å‡º");
        } catch (error) {
          console.log(`   âœ… æ­£ç¡®å¤„ç†ç©ºå†…å®¹ï¼š${error.message}`);
        }

        try {
          await splitArticleIntoSegments("æµ‹è¯•å†…å®¹", 0);
          console.error("   âŒ åº”è¯¥æŠ›å‡ºé”™è¯¯ï¼Œä½†æ²¡æœ‰æŠ›å‡º");
        } catch (error) {
          console.log(`   âœ… æ­£ç¡®å¤„ç†æ— æ•ˆå­—æ•°é™åˆ¶ï¼š${error.message}`);
        }

        // è¾“å‡ºæµ‹è¯•æ€»ç»“
        console.log("\nğŸ“Š æµ‹è¯•æ€»ç»“ï¼š");
        const successCount = results.filter(r => r.success).length;
        const failCount = results.filter(r => !r.success).length;
        console.log(`   æˆåŠŸï¼š${successCount} ä¸ªæµ‹è¯•`);
        console.log(`   å¤±è´¥ï¼š${failCount} ä¸ªæµ‹è¯•`);
        
        if (successCount > 0) {
          const avgDuration = results
            .filter(r => r.success)
            .reduce((sum, r) => sum + parseFloat(r.duration), 0) / successCount;
          console.log(`   å¹³å‡è€—æ—¶ï¼š${avgDuration.toFixed(2)} ç§’`);
        }

        // è¿”å›æµ‹è¯•ç»“æœä¾›è¿›ä¸€æ­¥åˆ†æ
        window.testSplitResults = results;
        console.log("\nğŸ’¡ æµ‹è¯•ç»“æœå·²ä¿å­˜åˆ° window.testSplitResultsï¼Œå¯åœ¨æ§åˆ¶å°æŸ¥çœ‹");
        
        return results;
      }

      // å°†æµ‹è¯•å‡½æ•°æš´éœ²åˆ°å…¨å±€ï¼Œæ–¹ä¾¿åœ¨æ§åˆ¶å°è°ƒç”¨
      window.testSplitArticleFunction = testSplitArticleFunction;
      window.splitArticleIntoSegments = splitArticleIntoSegments;

      // åˆ†å‰²æµ‹è¯•æŒ‰é’®
      splitTestButton.addEventListener("click", async () => {
        const title = splitTestTitle.value.trim() || "æœªå‘½åæ–‡ç« ";
        const content = splitTestContent.value.trim();
        const maxWordCount = parseInt(splitTestMaxWords.value) || 10000;
        
        if (!content) {
          showSplitTestStatus("è¯·è¾“å…¥æ–‡ç« å†…å®¹", "error");
          return;
        }
        
        const wordCount = calculateWordCount(content);
        if (wordCount === 0) {
          showSplitTestStatus("æ–‡ç« å†…å®¹ä¸ºç©º", "error");
          return;
        }
        
        splitTestButton.disabled = true;
        splitTestButton.textContent = "åˆ†å‰²ä¸­...";
        showSplitTestStatus(`æ­£åœ¨åˆ†å‰²æ–‡ç« ï¼ˆ${wordCount.toLocaleString()}å­—ï¼‰...`, "info");
        splitTestResult.style.display = "none";
        
        try {
          // ä½¿ç”¨å°è£…å¥½çš„å‡½æ•°
          const segments = await splitArticleIntoSegments(content, maxWordCount, title);
          
          // ä¿å­˜ç»“æœ
          splitTestResults = segments.map((segment, index) => ({
            ...segment,
            index: index
          }));
          
          // æ¸²æŸ“ç»“æœ
          renderSplitTestResult(splitTestResults);
          splitTestResult.style.display = "block";
          showSplitTestStatus(`åˆ†å‰²å®Œæˆï¼šåŸæ–‡ç«  ${wordCount.toLocaleString()} å­— â†’ åˆ†ä¸º ${segments.length} æ®µ`, "success");
        } catch (error) {
          console.error("åˆ†å‰²é”™è¯¯è¯¦æƒ…:", error);
          const errorMessage = error.message || String(error);
          showSplitTestStatus(`åˆ†å‰²å¤±è´¥: ${errorMessage}`, "error");
        } finally {
          splitTestButton.disabled = false;
          splitTestButton.textContent = "ğŸ”„ å¼€å§‹åˆ†å‰²";
        }
      });
      
      // æ˜¾ç¤ºåˆ†å‰²æµ‹è¯•çŠ¶æ€
      function showSplitTestStatus(message, type = "info") {
        splitTestStatus.className = `status ${type}`;
        // æ”¯æŒå¤šè¡Œæ¶ˆæ¯ï¼Œå°†æ¢è¡Œç¬¦è½¬æ¢ä¸º<br>
        splitTestStatus.innerHTML = message.replace(/\n/g, "<br>");
        splitTestStatus.style.display = "block";
        // å¦‚æœæ˜¯é”™è¯¯ï¼Œä¹Ÿæ»šåŠ¨åˆ°çŠ¶æ€åŒºåŸŸ
        if (type === "error") {
          splitTestStatus.scrollIntoView({ behavior: "smooth", block: "nearest" });
        }
      }
      
      // æ¸²æŸ“åˆ†å‰²æµ‹è¯•ç»“æœ
      function renderSplitTestResult(segments) {
        // æ¸²æŸ“æ ‡é¢˜åˆ—è¡¨
        let tocHtml = `<div style="display: flex; flex-direction: column; gap: 8px;">`;
        segments.forEach((segment, index) => {
          tocHtml += `
            <div onclick="selectSplitSegment(${index})" 
                 style="padding: 12px; border-radius: 6px; cursor: pointer; transition: all 0.2s; border-left: 3px solid #cbd5e1; background: #ffffff;"
                 id="splitSegment-${index}">
              <div style="font-weight: 600; color: #1e293b; margin-bottom: 4px; font-size: 14px;">
                ${index + 1}. ${escapeHtml(segment.title)}
              </div>
              <div style="font-size: 12px; color: #64748b;">
                ${segment.word_count.toLocaleString()} å­—
              </div>
            </div>
          `;
        });
        tocHtml += `</div>`;
        splitTestToc.innerHTML = tocHtml;
        
        // é»˜è®¤æ˜¾ç¤ºç¬¬ä¸€æ®µ
        if (segments.length > 0) {
          selectSplitSegment(0);
        }
      }
      
      // é€‰æ‹©åˆ†å‰²æ®µï¼ˆå…¨å±€å‡½æ•°ï¼‰
      window.selectSplitSegment = function(index) {
        if (index < 0 || index >= splitTestResults.length) return;
        
        // é«˜äº®é€‰ä¸­çš„é¡¹
        splitTestResults.forEach((_, i) => {
          const el = document.getElementById(`splitSegment-${i}`);
          if (el) {
            if (i === index) {
              el.style.background = "#e0e7ff";
              el.style.borderLeftColor = "#6366f1";
            } else {
              el.style.background = "#ffffff";
              el.style.borderLeftColor = "#cbd5e1";
            }
          }
        });
        
        // æ˜¾ç¤ºå†…å®¹
        const segment = splitTestResults[index];
        let contentHtml = `<div style="margin-bottom: 16px; padding: 12px; background: #f8fafc; border-radius: 8px; border-left: 4px solid #6366f1;">`;
        contentHtml += `<div style="font-weight: 600; font-size: 16px; color: #1e293b; margin-bottom: 8px;">${escapeHtml(segment.title)}</div>`;
        contentHtml += `<div style="font-size: 12px; color: #64748b;">å­—æ•°: ${segment.word_count.toLocaleString()} å­— | ç¬¬ ${index + 1}/${splitTestResults.length} æ®µ</div>`;
        contentHtml += `</div>`;
        contentHtml += `<div style="line-height: 1.8; color: #334155;">${(segment.content || "").replace(/\n/g, "<br>")}</div>`;
        
        splitTestContentDisplay.innerHTML = contentHtml;
        splitTestContentDisplay.scrollTop = 0;
      };
      
      // ä»æ•°æ®åº“åŠ è½½ä¹¦ç±åŠŸèƒ½
      loadFromDbButton.addEventListener("click", async () => {
        loadBookDialog.showModal();
        await loadBooksFromDatabase();
      });
      
      refreshBooksBtn.addEventListener("click", async () => {
        await loadBooksFromDatabase();
      });
      
      bookSearchInput.addEventListener("input", (e) => {
        filterBooks(e.target.value);
      });
      
      // åŠ è½½ä¹¦ç±åˆ—è¡¨
      async function loadBooksFromDatabase() {
        booksList.innerHTML = '<div style="text-align: center; padding: 40px; color: #94a3b8;"><span class="loading"></span> åŠ è½½ä¸­...</div>';
        
        try {
          const response = await fetch("/api/admin/books?page=1&per_page=100");
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error);
          }
          
          allBooks = data.books || [];
          renderBooksList(allBooks);
        } catch (error) {
          console.error(error);
          booksList.innerHTML = `<div style="text-align: center; padding: 40px; color: #ef4444;">åŠ è½½å¤±è´¥: ${error.message}</div>`;
        }
      }
      
      // æ¸²æŸ“ä¹¦ç±åˆ—è¡¨
      function renderBooksList(books) {
        if (books.length === 0) {
          booksList.innerHTML = '<div style="text-align: center; padding: 40px; color: #94a3b8;">æš‚æ— ä¹¦ç±æ•°æ®</div>';
          return;
        }
        
        booksList.innerHTML = "";
        books.forEach((book) => {
          const bookCard = document.createElement("div");
          bookCard.style.cssText = "padding: 16px; border: 1px solid #e2e8f0; border-radius: 8px; background: #ffffff; cursor: pointer; transition: all 0.2s;";
          bookCard.onmouseover = () => {
            bookCard.style.borderColor = "#8b5cf6";
            bookCard.style.boxShadow = "0 4px 12px rgba(139, 92, 246, 0.1)";
          };
          bookCard.onmouseout = () => {
            bookCard.style.borderColor = "#e2e8f0";
            bookCard.style.boxShadow = "none";
          };
          bookCard.onclick = () => loadBookFromDatabase(book.id);
          
          bookCard.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
              <div style="font-weight: 600; font-size: 16px; color: #1e293b;">${escapeHtml(book.filename)}</div>
              <div style="font-size: 12px; color: #64748b;">ID: ${book.id}</div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px; font-size: 13px;">
              <div>
                <div style="color: #64748b; margin-bottom: 4px;">ç« èŠ‚æ•°</div>
                <div style="color: #1e293b; font-weight: 500;">${book.chapter_count} ç« </div>
              </div>
              <div>
                <div style="color: #64748b; margin-bottom: 4px;">æ€»å­—æ•°</div>
                <div style="color: #1e293b; font-weight: 500;">${book.total_word_count.toLocaleString()} å­—</div>
              </div>
              <div>
                <div style="color: #64748b; margin-bottom: 4px;">å…¥åº“æ—¶é—´</div>
                <div style="color: #1e293b; font-weight: 500; font-size: 12px;">${new Date(book.created_at).toLocaleDateString("zh-CN")}</div>
              </div>
            </div>
            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #f1f5f9;">
              <button style="width: 100%; padding: 8px; background: #8b5cf6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                åŠ è½½æ­¤ä¹¦ç±
              </button>
            </div>
          `;
          
          booksList.appendChild(bookCard);
        });
      }
      
      // è¿‡æ»¤ä¹¦ç±
      function filterBooks(searchText) {
        if (!searchText.trim()) {
          renderBooksList(allBooks);
          return;
        }
        
        const filtered = allBooks.filter(book => 
          book.filename.toLowerCase().includes(searchText.toLowerCase())
        );
        renderBooksList(filtered);
      }
      
      // HTMLè½¬ä¹‰
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }
      
      // ä»æ•°æ®åº“åŠ è½½ä¹¦ç±æ•°æ®
      async function loadBookFromDatabase(bookId) {
        loadBookDialog.close();
        loadFromDbButton.disabled = true;
        renderStatus("æ­£åœ¨ä»æ•°æ®åº“åŠ è½½ä¹¦ç±æ•°æ®...", "info");
        
        try {
          const response = await fetch(`/api/admin/books/${bookId}`);
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error);
          }
          
          const book = data.book;
          const chapters = data.chapters || [];
          
          if (chapters.length === 0) {
            throw new Error("è¯¥ä¹¦ç±æ²¡æœ‰ç« èŠ‚æ•°æ®");
          }
          
          // è½¬æ¢ä¸ºparsedEntriesæ ¼å¼
          // æ³¨æ„ï¼šåç«¯APIè¿”å›çš„å­—æ®µåæ˜¯ title, title_zh, content, content_zh
          parsedEntries = chapters.map((chapter, index) => ({
            title: chapter.title || `ç¬¬ ${index + 1} ç« `,
            title_zh: chapter.title_zh || chapter.title || `ç¬¬ ${index + 1} ç« `,
            content: chapter.content || "",
            content_zh: chapter.content_zh || chapter.content || "",
            word_count: chapter.word_count || 0,
            summary: chapter.summary || ""
          }));
          
          // è°ƒè¯•ï¼šæ£€æŸ¥ç¬¬ä¸€ä¸ªç« èŠ‚çš„å†…å®¹
          if (parsedEntries.length > 0) {
            console.log("åŠ è½½çš„ç« èŠ‚æ•°æ®ç¤ºä¾‹:", {
              title: parsedEntries[0].title,
              title_zh: parsedEntries[0].title_zh,
              content_length: parsedEntries[0].content?.length || 0,
              content_zh_length: parsedEntries[0].content_zh?.length || 0,
              word_count: parsedEntries[0].word_count
            });
          }
          
          currentFilename = book.filename;
          currentFileType = book.filename.toLowerCase().endsWith('.epub') ? 'epub' : 'pdf';
          cleanedTocData = null; // ä»æ•°æ®åº“åŠ è½½æ—¶ä¸éœ€è¦æ¸…æ´—ç›®å½•
          
          // æ¸²æŸ“è¡¨æ ¼
          renderTable(parsedEntries);
          
          // å¯ç”¨ç›¸å…³æŒ‰é’®
          ingestButton.disabled = false;
          restructureButton.disabled = false;
          const tocSummaryButton = document.getElementById("tocSummaryButton");
          if (tocSummaryButton) {
            tocSummaryButton.disabled = false;
          }
          
          renderStatus(`æˆåŠŸåŠ è½½ä¹¦ç±: ${book.filename} (${chapters.length} ç« )`, "success");
        } catch (error) {
          console.error(error);
          renderStatus(`åŠ è½½å¤±è´¥: ${error.message}`, "error");
        } finally {
          loadFromDbButton.disabled = false;
        }
      }

      function renderTocCompare(rawToc, cleanedToc) {
        rawCount.textContent = rawToc.length;
        cleanedCount.textContent = cleanedToc.length;

        rawTocList.innerHTML = "";
        rawToc.forEach((item) => {
          const div = document.createElement("div");
          div.style.paddingLeft = `${(item.level - 1) * 20}px`;
          div.style.marginBottom = "4px";
          div.textContent = `${item.title} (ç¬¬${item.page}é¡µ)`;
          rawTocList.appendChild(div);
        });

        cleanedTocList.innerHTML = "";
        cleanedToc.forEach((item) => {
          const div = document.createElement("div");
          div.style.paddingLeft = `${(item.level - 1) * 20}px`;
          div.style.marginBottom = "4px";
          div.textContent = `${item.title} (ç¬¬${item.page}é¡µ)`;
          cleanedTocList.appendChild(div);
        });

        tocCompareDialog.showModal();
      }

      function renderStatus(message, type = "info") {
        statusArea.className = `status ${type}`;
        const loading = type === "info" && (message.includes("æ­£åœ¨") || message.includes("è¯·ç¨å€™")) 
          ? '<span class="loading"></span>' 
          : '';
        statusArea.innerHTML = loading + message;
      }

      function showProgress(total = 0, label = "æ­£åœ¨å‡†å¤‡å…¥åº“...") {
        if (!progressWrapper) return;
        progressWrapper.classList.add("active");
        updateProgress(0, total, label);
      }

      function updateProgress(completed, total, label) {
        if (!progressWrapper) return;
        if (!progressWrapper.classList.contains("active")) {
          progressWrapper.classList.add("active");
        }
        if (progressWrapper.style.display !== "block") {
          progressWrapper.style.display = "block";
        }
        const percent = total > 0 ? Math.min(100, Math.max(0, Math.round((completed / total) * 100))) : 0;
        if (progressFill) {
          progressFill.style.width = `${percent}%`;
        }
        if (progressLabel) {
          progressLabel.textContent = label || `è¿›åº¦ï¼š${completed}/${total} (${percent}%)`;
        }
      }

      function hideProgress() {
        if (!progressWrapper) return;
        progressWrapper.classList.remove("active");
        progressWrapper.style.display = "none";
        if (progressFill) {
          progressFill.style.width = "0%";
        }
      }

      function renderTable(entries) {
        if (!entries || entries.length === 0) {
          resultsBody.innerHTML = `<tr><td colspan="6" style="text-align: center; color: #94a3b8; padding: 40px;">æœªè¯†åˆ«åˆ°æœ‰æ•ˆç›®å½•ã€‚</td></tr>`;
          ingestButton.disabled = true;
          const tocSummaryButton = document.getElementById("tocSummaryButton");
          if (tocSummaryButton) {
            tocSummaryButton.disabled = true;
          }
          return;
        }

        resultsBody.innerHTML = "";
        ingestButton.disabled = false;
        restructureButton.disabled = false;
        for (let index = 0; index < entries.length; index++) {
          const entry = entries[index];
          const row = document.createElement("tr");

          // ä½¿ç”¨ä¸­æ–‡æ ‡é¢˜ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨åŸæ–‡
          const titleCell = document.createElement("td");
          const displayTitle = entry.title_zh || entry.title;
          titleCell.textContent = displayTitle;
          // å¦‚æœåŸæ–‡å’Œä¸­æ–‡ä¸åŒï¼Œæ˜¾ç¤ºæç¤º
          if (entry.title_zh && entry.title_zh !== entry.title) {
            titleCell.title = `åŸæ–‡: ${entry.title}`;
            titleCell.style.color = "#2563eb";
          }

          const contentCell = document.createElement("td");
          
          // åˆ›å»ºæŒ‰é’®å®¹å™¨
          const buttonContainer = document.createElement("div");
          buttonContainer.style.display = "flex";
          buttonContainer.style.gap = "8px";
          buttonContainer.style.flexWrap = "wrap";
          
          // æŸ¥çœ‹å®Œæ•´å†…å®¹æŒ‰é’®
          const viewButton = document.createElement("button");
          viewButton.textContent = "æŸ¥çœ‹å®Œæ•´å†…å®¹";
          viewButton.style.fontSize = "13px";
          viewButton.style.padding = "6px 12px";
          viewButton.addEventListener("click", () => {
            // æ˜¾ç¤ºä¸­æ–‡å†…å®¹ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ˜¾ç¤ºåŸæ–‡
            const displayContent = entry.content_zh || entry.content || "(æš‚æ— æ­£æ–‡å†…å®¹)";
            dialogTitle.textContent = displayTitle;
            dialogContent.textContent = displayContent;
            // å¦‚æœåŸæ–‡å’Œä¸­æ–‡ä¸åŒï¼Œåœ¨æ ‡é¢˜ä¸­æ˜¾ç¤ºæç¤º
            if (entry.content_zh && entry.content_zh !== entry.content) {
              dialogTitle.textContent = `${displayTitle} (å·²ç¿»è¯‘)`;
            }
            dialog.showModal();
          });
          buttonContainer.appendChild(viewButton);
          
          // æ·±åº¦è§£è¯»æŒ‰é’®
          const deepInterpretButton = document.createElement("button");
          deepInterpretButton.textContent = "æ·±åº¦è§£è¯»";
          deepInterpretButton.style.fontSize = "13px";
          deepInterpretButton.style.padding = "6px 12px";
          deepInterpretButton.style.background = "#8b5cf6";
          deepInterpretButton.style.color = "white";
          deepInterpretButton.style.border = "none";
          deepInterpretButton.style.borderRadius = "6px";
          deepInterpretButton.style.cursor = "pointer";
          deepInterpretButton.addEventListener("click", async () => {
            const content = entry.content_zh || entry.content || "";
            const title = entry.title_zh || entry.title || "";
            
            if (!content) {
              renderStatus("è¯¥ç« èŠ‚æ²¡æœ‰å†…å®¹å¯ä¾›è§£è¯»", "error");
              return;
            }
            
            deepInterpretButton.disabled = true;
            deepInterpretButton.textContent = "è§£è¯»ä¸­...";
            renderStatus(`æ­£åœ¨æ·±åº¦è§£è¯»ç« èŠ‚: ${title}...`, "info");
            
            try {
              // è·å–é…ç½®çš„æç¤ºè¯ï¼ˆä» localStorage æˆ–ä½¿ç”¨é»˜è®¤å€¼ï¼‰
              const interpretationPrompt = getInterpretationPrompt();
              
              const result = await interpretWithDeepThinking(content, interpretationPrompt, {
                replacements: {
                  chapter_fulltext: content,
                  chapter_title: title
                }
              });
              
              // åªæ˜¾ç¤ºæœ€ç»ˆç»“æœï¼ˆcontentï¼‰ï¼Œä¸æ˜¾ç¤ºæ€è€ƒè¿‡ç¨‹ï¼ˆreasoning_contentï¼‰
              // å¦‚æœ content ä¸­åŒ…å«"ã€è§£è¯»ç»“æœã€‘"å‰ç¼€ï¼Œæå–åé¢çš„å†…å®¹
              if (result.content) {
                let displayContent = result.content;
                
                // æå–"ã€è§£è¯»ç»“æœã€‘"åé¢çš„å†…å®¹
                const resultMatch = displayContent.match(/ã€è§£è¯»ç»“æœã€‘\s*\n*\s*(.*)/s);
                if (resultMatch && resultMatch[1]) {
                  displayContent = resultMatch[1].trim();
                } else {
                  // å¦‚æœæ²¡æœ‰"ã€è§£è¯»ç»“æœã€‘"æ ‡è®°ï¼Œå°è¯•æå–ç¬¬ä¸€ä¸ªæ ‡è®°åé¢çš„å†…å®¹
                  // æˆ–è€…å…¶ä»–å¸¸è§æ ¼å¼
                  const altMatch = displayContent.match(/(?:è§£è¯»ç»“æœ|ç»“æœ)[ï¼š:]\s*\n*\s*(.*)/s);
                  if (altMatch && altMatch[1]) {
                    displayContent = altMatch[1].trim();
                  }
                }
                
                dialogTitle.textContent = `${displayTitle} - æ·±åº¦è§£è¯»`;
                dialogContent.textContent = displayContent;
                dialog.showModal();
                renderStatus(`ç« èŠ‚æ·±åº¦è§£è¯»å®Œæˆ: ${title}`, "success");
              } else {
                renderStatus("è§£è¯»ç»“æœä¸ºç©º", "warning");
              }
            } catch (error) {
              console.error(error);
              renderStatus(`æ·±åº¦è§£è¯»å¤±è´¥: ${error.message}`, "error");
            } finally {
              deepInterpretButton.disabled = false;
              deepInterpretButton.textContent = "æ·±åº¦è§£è¯»";
            }
          });
          buttonContainer.appendChild(deepInterpretButton);
          
          contentCell.appendChild(buttonContainer);

          const countCell = document.createElement("td");
          const count = entry.word_count || 0;
          countCell.innerHTML = `<span style="font-weight: 500; color: #475569;">${count.toLocaleString()}</span> <span style="color: #94a3b8; font-size: 12px;">å­—</span>`;

          // ç¿»è¯‘æŒ‰é’®åˆ—
          const translateCell = document.createElement("td");
          // åˆ¤æ–­æ˜¯å¦å·²ç¿»è¯‘ï¼šæ ‡é¢˜å’Œå†…å®¹éƒ½å¿…é¡»æœ‰ç¿»è¯‘ï¼Œä¸”éƒ½ä¸åŸæ–‡ä¸åŒ
          const hasTranslation = entry.title_zh && entry.content_zh && 
                                 entry.title_zh !== entry.title && entry.content_zh !== entry.content;
          
          // æ ¹æ®"æ˜¯å¦ç¿»è¯‘ä¹¦ç±"å¼€å…³å†³å®šæ˜¯å¦æ˜¾ç¤ºç¿»è¯‘æŒ‰é’®
          const shouldTranslate = translateBookCheckbox && translateBookCheckbox.checked;
          
          if (hasTranslation) {
            // å·²æœ‰ç¿»è¯‘ï¼Œæ˜¾ç¤ºçŠ¶æ€
            translateCell.innerHTML = '<span style="color: #10b981; font-size: 12px;">âœ“ å·²ç¿»è¯‘</span>';
          } else if (shouldTranslate && entry.title) {
            // å¼€å…³æ‰“å¼€ï¼Œæ˜¾ç¤ºç¿»è¯‘æŒ‰é’®
            const translateButton = document.createElement("button");
            translateButton.textContent = "ğŸŒ ç¿»è¯‘";
            translateButton.style.fontSize = "13px";
            translateButton.style.padding = "6px 12px";
            translateButton.style.background = "#10b981";
            translateButton.style.color = "white";
            translateButton.style.border = "none";
            translateButton.style.borderRadius = "6px";
            translateButton.style.cursor = "pointer";
            translateButton.addEventListener("click", async () => {
              translateButton.disabled = true;
              translateButton.textContent = "ç¿»è¯‘ä¸­...";
              renderStatus(`æ­£åœ¨ç¿»è¯‘ç« èŠ‚: ${entry.title}...`, "info");
              
              try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 600000); // 10åˆ†é’Ÿè¶…æ—¶ï¼Œæ”¯æŒé•¿æ–‡æœ¬ç¿»è¯‘
                
                let response;
                try {
                  response = await fetch("/api/translate/chapter", {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                      title: entry.title,
                      content: entry.content || "",
                    }),
                    signal: controller.signal,
                  });
                } catch (fetchError) {
                  clearTimeout(timeoutId);
                  if (fetchError.name === "AbortError") {
                    throw new Error("ç¿»è¯‘è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•æˆ–åˆ†æ®µç¿»è¯‘");
                  }
                  throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${fetchError.message}`);
                }
                clearTimeout(timeoutId);

                if (!response.ok) {
                  let errorMessage = `ç¿»è¯‘å¤±è´¥ (çŠ¶æ€ç : ${response.status})`;
                  try {
                    const errorText = await response.text();
                    try {
                      const errorData = JSON.parse(errorText);
                      errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                      errorMessage = errorText || errorMessage;
                    }
                  } catch (e) {
                    // å¦‚æœæ— æ³•è¯»å–å“åº”ï¼Œä½¿ç”¨é»˜è®¤é”™è¯¯æ¶ˆæ¯
                  }
                  throw new Error(errorMessage);
                }

                const payload = await response.json();
                // æ›´æ–°entryæ•°æ®ï¼ˆentryæ˜¯parsedEntriesä¸­çš„å¼•ç”¨ï¼Œä¼šè‡ªåŠ¨åŒæ­¥ï¼‰
                entry.title_zh = payload.title_zh || entry.title_zh;
                entry.content_zh = payload.content_zh || entry.content_zh;
                // å¦‚æœç¿»è¯‘åç”Ÿæˆäº†æ¦‚è¦ï¼Œä¹Ÿæ›´æ–°æ¦‚è¦
                if (payload.summary) {
                  entry.summary = payload.summary;
                }
                
                // é‡æ–°æ¸²æŸ“è¡¨æ ¼ä»¥æ›´æ–°æ˜¾ç¤ºï¼ˆä½¿ç”¨å…¨å±€parsedEntriesï¼‰
                renderTable(parsedEntries);
                
                // æ˜¾ç¤ºç¿»è¯‘ç»“æœæ¶ˆæ¯
                const titleTranslated = payload.title_zh && payload.title_zh !== entry.title;
                const contentTranslated = payload.content_zh && payload.content_zh !== entry.content;
                
                if (payload.warning) {
                  // æœ‰è­¦å‘Šï¼ˆç¿»è¯‘å¤±è´¥ï¼‰
                  renderStatus(payload.warning, "warning");
                } else if (titleTranslated && contentTranslated) {
                  // ç¿»è¯‘æˆåŠŸ
                  const successMsg = payload.summary 
                    ? `ç« èŠ‚ç¿»è¯‘å®Œæˆå¹¶å·²ç”Ÿæˆæ¦‚è¦: ${payload.title_zh}`
                    : `ç« èŠ‚ç¿»è¯‘å®Œæˆ: ${payload.title_zh}`;
                  renderStatus(successMsg, "success");
                } else if (titleTranslated && !contentTranslated) {
                  // æ ‡é¢˜ç¿»è¯‘æˆåŠŸï¼Œä½†å†…å®¹ç¿»è¯‘å¤±è´¥
                  renderStatus(`æ ‡é¢˜ç¿»è¯‘å®Œæˆï¼Œä½†å†…å®¹ç¿»è¯‘å¤±è´¥: ${payload.title_zh}`, "warning");
                } else if (!titleTranslated && contentTranslated) {
                  // æ ‡é¢˜ç¿»è¯‘å¤±è´¥ï¼Œä½†å†…å®¹ç¿»è¯‘æˆåŠŸ
                  renderStatus(`å†…å®¹ç¿»è¯‘å®Œæˆï¼Œä½†æ ‡é¢˜ç¿»è¯‘å¤±è´¥`, "warning");
                } else {
                  // éƒ½ç¿»è¯‘å¤±è´¥
                  renderStatus(`ç¿»è¯‘å¤±è´¥: æ ‡é¢˜å’Œå†…å®¹éƒ½æœªèƒ½ç¿»è¯‘`, "error");
                }
              } catch (error) {
                console.error(error);
                translateButton.disabled = false;
                translateButton.textContent = "ğŸŒ ç¿»è¯‘";
                renderStatus(error.message, "error");
              }
            });
            translateCell.appendChild(translateButton);
          } else {
            // å¼€å…³æœªæ‰“å¼€ï¼Œä¸æ˜¾ç¤ºç¿»è¯‘æŒ‰é’®
            translateCell.innerHTML = '<span style="color: #94a3b8; font-size: 12px;">â€”</span>';
          }

          const summaryCell = document.createElement("td");
          if (entry.summary) {
            const summaryButton = document.createElement("button");
            summaryButton.textContent = "æŸ¥çœ‹ç« èŠ‚æ¦‚è¿°";
            summaryButton.style.fontSize = "13px";
            summaryButton.style.padding = "6px 12px";
            summaryButton.addEventListener("click", () => {
              dialogTitle.textContent = `${displayTitle} - æ¦‚è¿°`;
              dialogContent.textContent = entry.summary || "(æš‚æ— æ¦‚è¿°)";
              dialog.showModal();
            });
            summaryCell.appendChild(summaryButton);
          } else {
            summaryCell.innerHTML = '<span style="color: #94a3b8;">â€”</span>';
          }

          // é‡æ„æŒ‰é’®åˆ—
          const restructureCell = document.createElement("td");
          const restructureButton = document.createElement("button");
          restructureButton.textContent = "ğŸ”„ é‡æ„";
          restructureButton.style.fontSize = "13px";
          restructureButton.style.padding = "6px 12px";
          restructureButton.style.background = "#8b5cf6";
          restructureButton.style.color = "white";
          restructureButton.style.border = "none";
          restructureButton.style.borderRadius = "6px";
          restructureButton.style.cursor = "pointer";
          restructureButton.addEventListener("click", async () => {
            const content = entry.content_zh || entry.content || "";
            const title = entry.title_zh || entry.title || "";
            
            if (!content) {
              renderStatus("è¯¥ç« èŠ‚æ²¡æœ‰å†…å®¹å¯ä¾›é‡æ„", "error");
              return;
            }

            // è·å–å­—æ•°ä¸Šé™
            const maxLengthInput = document.getElementById("restructureMaxLength");
            const maxLength = parseInt(maxLengthInput?.value || "5000");
            if (isNaN(maxLength) || maxLength <= 0) {
              renderStatus("å­—æ•°ä¸Šé™è®¾ç½®æ— æ•ˆï¼Œè¯·æ£€æŸ¥è¾“å…¥", "error");
              return;
            }

            restructureButton.disabled = true;
            restructureButton.textContent = "é‡æ„ä¸­...";
            renderStatus(`æ­£åœ¨é‡æ„ç« èŠ‚: ${title}ï¼ˆå­—æ•°ä¸Šé™: ${maxLength.toLocaleString()}å­—ï¼‰...`, "info");

            try {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 600000); // 10åˆ†é’Ÿè¶…æ—¶

              let response;
              try {
                response = await fetch("/api/restructure/split-article", {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                  },
                  body: JSON.stringify({
                    text: content,
                    max_length: maxLength,
                    title: title
                  }),
                  signal: controller.signal,
                });
              } catch (fetchError) {
                clearTimeout(timeoutId);
                if (fetchError.name === "AbortError") {
                  throw new Error("è¯·æ±‚è¶…æ—¶ï¼ˆè¶…è¿‡10åˆ†é’Ÿï¼‰ï¼Œè¯·ç¨åé‡è¯•æˆ–å‡å°‘æ–‡ç« é•¿åº¦");
                }
                const errorMsg = fetchError.message || String(fetchError);
                if (errorMsg.includes("Failed to fetch") || errorMsg.includes("NetworkError")) {
                  throw new Error("æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ï¼š\n1. æœåŠ¡å™¨æ˜¯å¦æ­£åœ¨è¿è¡Œï¼ˆç«¯å£5001ï¼‰\n2. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸\n3. æµè§ˆå™¨æ§åˆ¶å°æ˜¯å¦æœ‰æ›´å¤šé”™è¯¯ä¿¡æ¯");
                }
                throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${errorMsg}`);
              }
              clearTimeout(timeoutId);

              if (!response.ok) {
                let errorMessage = `é‡æ„å¤±è´¥ (çŠ¶æ€ç : ${response.status})`;
                try {
                  const errorText = await response.text();
                  try {
                    const errorData = JSON.parse(errorText);
                    errorMessage = errorData.error || errorMessage;
                  } catch (e) {
                    errorMessage = errorText || errorMessage;
                  }
                } catch (e) {
                  // å¦‚æœæ— æ³•è¯»å–å“åº”ï¼Œä½¿ç”¨é»˜è®¤é”™è¯¯æ¶ˆæ¯
                }
                throw new Error(errorMessage);
              }

              let splitResult;
              try {
                splitResult = await response.json();
              } catch (jsonError) {
                throw new Error(`æœåŠ¡å™¨å“åº”æ ¼å¼é”™è¯¯: ${jsonError.message}`);
              }

              const segments = splitResult.segments || [];

              if (segments.length === 0) {
                throw new Error("é‡æ„å¤±è´¥ï¼Œæœªç”Ÿæˆä»»ä½•ç‰‡æ®µ");
              }

              // æ˜¾ç¤ºé‡æ„ç»“æœ
              renderRestructureResult(title, segments);
              renderStatus(`ç« èŠ‚é‡æ„å®Œæˆ: ${title} â†’ åˆ†ä¸º ${segments.length} æ®µ`, "success");
            } catch (error) {
              console.error("é‡æ„é”™è¯¯è¯¦æƒ…:", error);
              const errorMessage = error.message || String(error);
              renderStatus(`é‡æ„å¤±è´¥: ${errorMessage}`, "error");
            } finally {
              restructureButton.disabled = false;
              restructureButton.textContent = "ğŸ”„ é‡æ„";
            }
          });
          restructureCell.appendChild(restructureButton);

          row.appendChild(titleCell);
          row.appendChild(contentCell);
          row.appendChild(countCell);
          row.appendChild(translateCell);
          row.appendChild(summaryCell);
          row.appendChild(restructureCell);
          resultsBody.appendChild(row);
        }
      }

      cleanTocButton.addEventListener("click", async () => {
        if (!pdfFile.files.length) {
          renderStatus("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ï¼ˆPDFæˆ–EPUBï¼‰ã€‚", "error");
          return;
        }

        const formData = new FormData();
        formData.append("file", pdfFile.files[0]);

        cleanTocButton.disabled = true;
        renderStatus("æ­£åœ¨æ¸…æ´—ç›®å½•ï¼Œè¯·ç¨å€™...", "info");

        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 300000);

          let response;
          try {
            response = await fetch("/api/parse/clean_toc", {
              method: "POST",
              body: formData,
              signal: controller.signal,
            });
          } catch (fetchError) {
            clearTimeout(timeoutId);
            if (fetchError.name === "AbortError") {
              throw new Error("è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•");
            }
            throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${fetchError.message}`);
          }
          clearTimeout(timeoutId);

          let payload;
          try {
            payload = await response.json();
          } catch (jsonError) {
            throw new Error(`æœåŠ¡å™¨å“åº”æ ¼å¼é”™è¯¯: ${jsonError.message}`);
          }

          if (!response.ok) {
            throw new Error(payload.error || `æ¸…æ´—ç›®å½•å¤±è´¥ (çŠ¶æ€ç : ${response.status})`);
          }

          cleanedTocData = payload.cleaned_toc || [];
          currentFilename = payload.filename || "æœªçŸ¥æ–‡ä»¶";
          currentFileType = payload.file_type || null;
          
          // è°ƒè¯•æ—¥å¿—
          console.log("æ­¥éª¤1å®Œæˆï¼šæ¸…æ´—åçš„ç›®å½•ï¼Œå…±", cleanedTocData.length, "ä¸ªæ¡ç›®");
          if (cleanedTocData.length > 0) {
            console.log("æ¸…æ´—åç›®å½•ç¤ºä¾‹ï¼š", cleanedTocData[0]);
          }
          
          renderStatus("ç›®å½•æ¸…æ´—å®Œæˆï¼Œè¯·æŸ¥çœ‹å¯¹æ¯”ç»“æœã€‚", "success");
          renderTocCompare(payload.raw_toc || [], payload.cleaned_toc || []);
          extractButton.disabled = false;
        } catch (error) {
          console.error(error);
          renderStatus(error.message, "error");
          cleanedTocData = null;
          extractButton.disabled = true;
        } finally {
          cleanTocButton.disabled = false;
        }
      });

      testTranslateButton.addEventListener("click", () => {
        translateTestDialog.showModal();
        translateInput.value = "";
        translateOutput.textContent = "";
      });

      doTranslateButton.addEventListener("click", async () => {
        const text = translateInput.value.trim();
        if (!text) {
          renderStatus("è¯·è¾“å…¥è¦ç¿»è¯‘çš„æ–‡æœ¬ã€‚", "error");
          return;
        }

        doTranslateButton.disabled = true;
        translateOutput.textContent = "æ­£åœ¨ç¿»è¯‘...";
        renderStatus("æ­£åœ¨ç¿»è¯‘æ–‡æœ¬...", "info");

        try {
          const response = await fetch("/api/translate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ text }),
          });

          if (!response.ok) {
            let errorMessage = `ç¿»è¯‘å¤±è´¥ (çŠ¶æ€ç : ${response.status})`;
            try {
              const errorText = await response.text();
              try {
                const errorData = JSON.parse(errorText);
                errorMessage = errorData.error || errorMessage;
              } catch (e) {
                errorMessage = errorText || errorMessage;
              }
            } catch (e) {
              // å¦‚æœæ— æ³•è¯»å–å“åº”ï¼Œä½¿ç”¨é»˜è®¤é”™è¯¯æ¶ˆæ¯
            }
            throw new Error(errorMessage);
          }

          const payload = await response.json();
          translateOutput.textContent = payload.translated || payload.result || "ç¿»è¯‘å¤±è´¥";
          renderStatus("ç¿»è¯‘å®Œæˆã€‚", "success");
        } catch (error) {
          console.error(error);
          translateOutput.textContent = `ç¿»è¯‘å¤±è´¥: ${error.message}`;
          renderStatus(error.message, "error");
        } finally {
          doTranslateButton.disabled = false;
        }
      });

      extractButton.addEventListener("click", async () => {
        if (!pdfFile.files.length) {
          renderStatus("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ï¼ˆPDFæˆ–EPUBï¼‰ã€‚", "error");
          return;
        }

        if (!cleanedTocData || cleanedTocData.length === 0) {
          renderStatus("è¯·å…ˆå®Œæˆæ­¥éª¤1ï¼šç›®å½•æ¸…æ´—ã€‚", "error");
          return;
        }

        const formData = new FormData();
        formData.append("file", pdfFile.files[0]);

        extractButton.disabled = true;
        renderStatus("æ­£åœ¨æå–å†…å®¹å¹¶ç»Ÿè®¡ï¼Œè¯·ç¨å€™...", "info");
        renderTable([]);

        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 300000);

          // éªŒè¯æ¸…æ´—åçš„ç›®å½•æ•°æ®
          if (!cleanedTocData || cleanedTocData.length === 0) {
            renderStatus("é”™è¯¯ï¼šæ¸…æ´—åçš„ç›®å½•ä¸ºç©ºï¼Œè¯·é‡æ–°æ‰§è¡Œæ­¥éª¤1ã€‚", "error");
            return;
          }

          // è°ƒè¯•æ—¥å¿—
          console.log("æ­¥éª¤2ï¼šä½¿ç”¨æ¸…æ´—åçš„ç›®å½•ï¼Œå…±", cleanedTocData.length, "ä¸ªæ¡ç›®");
          console.log("æ¸…æ´—åç›®å½•ç¤ºä¾‹ï¼š", cleanedTocData[0]);

          // ä½¿ç”¨FormDataå‘é€æ–‡ä»¶å’ŒJSONæ•°æ®
          const formDataWithJson = new FormData();
          formDataWithJson.append("file", pdfFile.files[0]);
          formDataWithJson.append("cleaned_toc", JSON.stringify(cleanedTocData));
          if (currentFileType) {
            formDataWithJson.append("file_type", currentFileType);
          }

          let response;
          try {
            response = await fetch("/api/parse/extract", {
              method: "POST",
              body: formDataWithJson,
              signal: controller.signal,
            });
          } catch (fetchError) {
            clearTimeout(timeoutId);
            if (fetchError.name === "AbortError") {
              throw new Error("è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•");
            }
            throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${fetchError.message}`);
          }
          clearTimeout(timeoutId);

          let payload;
          try {
            payload = await response.json();
          } catch (jsonError) {
            throw new Error(`æœåŠ¡å™¨å“åº”æ ¼å¼é”™è¯¯: ${jsonError.message}`);
          }

          if (!response.ok) {
            throw new Error(payload.error || `æå–å†…å®¹å¤±è´¥ (çŠ¶æ€ç : ${response.status})`);
          }

          renderStatus("å†…å®¹æå–å®Œæˆï¼Œè¯·éªŒæ”¶ç»“æœã€‚", "success");
          parsedEntries = payload.entries || [];
          currentFilename = payload.filename || currentFilename;
          renderTable(parsedEntries);
          ingestButton.disabled = parsedEntries.length === 0;
          restructureButton.disabled = parsedEntries.length === 0;
        } catch (error) {
          console.error(error);
          renderStatus(error.message, "error");
          parsedEntries = [];
          renderTable([]);
          restructureButton.disabled = true;
        } finally {
          extractButton.disabled = false;
        }
      });
      
      // è®¡ç®—å­—æ•°ï¼ˆä½¿ç”¨ç®—æ³•ï¼Œä¸ä¾èµ–AIï¼‰
      function calculateWordCount(text) {
        if (!text) return 0;
        // å»é™¤æ‰€æœ‰ç©ºæ ¼å’Œæ¢è¡Œç¬¦åè®¡ç®—å­—ç¬¦æ•°
        return text.replace(/\s+/g, "").length;
      }
      
      // æ–‡ç« ç»“æ„é‡æ„åŠŸèƒ½
      restructureButton.addEventListener("click", async () => {
        if (!parsedEntries.length) {
          renderStatus("è¯·å…ˆå®Œæˆè§£æã€‚", "error");
          return;
        }
        
        restructureButton.disabled = true;
        renderStatus("æ­£åœ¨é‡æ„æ–‡ç« ç»“æ„ï¼Œè¯·ç¨å€™...", "info");
        showProgress(parsedEntries.length, "æ­£åœ¨åˆ†æç« èŠ‚ç»“æ„...");
        
        try {
          const MAX_WORD_COUNT = 10000; // æ¯ä¸ªå•å…ƒæœ€å¤š1ä¸‡å­—
          const newEntries = [];
          
          for (let index = 0; index < parsedEntries.length; index++) {
            const entry = parsedEntries[index];
            const title = entry.title_zh || entry.title || `ç¬¬ ${index + 1} ç« `;
            const content = entry.content_zh || entry.content || "";
            
            updateProgress(index, parsedEntries.length, `æ­£åœ¨å¤„ç†: ${title}`);
            
            // è®¡ç®—å­—æ•°
            const wordCount = calculateWordCount(content);
            
            if (wordCount <= MAX_WORD_COUNT) {
              // å°äºç­‰äº1ä¸‡å­—ï¼Œä¿æŒåŸæ ·
              newEntries.push({
                title: title,
                content: content,
                word_count: wordCount,
                original_index: index,
                split: false
              });
            } else {
              // è¶…è¿‡1ä¸‡å­—ï¼Œéœ€è¦åˆ†å‰²
              updateProgress(index, parsedEntries.length, `æ­£åœ¨åˆ†å‰²ç« èŠ‚ï¼ˆ${wordCount.toLocaleString()}å­—ï¼‰: ${title}`);
              
              try {
                // è°ƒç”¨åç«¯APIè¿›è¡Œè¯­ä¹‰åˆ†å‰²
                const response = await fetch("/api/restructure/split-chapter", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    title: title,
                    content: content,
                    max_word_count: MAX_WORD_COUNT,
                    word_count: wordCount
                  }),
                });
                
                if (!response.ok) {
                  const errorData = await response.json().catch(() => ({ error: "åˆ†å‰²å¤±è´¥" }));
                  throw new Error(errorData.error || `åˆ†å‰²å¤±è´¥ (çŠ¶æ€ç : ${response.status})`);
                }
                
                const splitResult = await response.json();
                const segments = splitResult.segments || [];
                
                if (segments.length === 0) {
                  // å¦‚æœåˆ†å‰²å¤±è´¥ï¼Œä¿æŒåŸæ ·
                  newEntries.push({
                    title: title,
                    content: content,
                    word_count: wordCount,
                    original_index: index,
                    split: false,
                    warning: "åˆ†å‰²å¤±è´¥ï¼Œä¿æŒåŸæ ·"
                  });
                } else {
                  // æ·»åŠ åˆ†å‰²åçš„ç« èŠ‚
                  segments.forEach((segment, segIndex) => {
                    newEntries.push({
                      title: segment.title || `${title} (ç¬¬${segIndex + 1}éƒ¨åˆ†)`,
                      content: segment.content || "",
                      word_count: segment.word_count || calculateWordCount(segment.content || ""),
                      original_index: index,
                      split: true,
                      segment_index: segIndex,
                      total_segments: segments.length
                    });
                  });
                }
              } catch (error) {
                console.error(`åˆ†å‰²ç« èŠ‚å¤±è´¥: ${title}`, error);
                // åˆ†å‰²å¤±è´¥æ—¶ä¿æŒåŸæ ·ï¼Œä½†æ ‡è®°è­¦å‘Š
                newEntries.push({
                  title: title,
                  content: content,
                  word_count: wordCount,
                  original_index: index,
                  split: false,
                  warning: `åˆ†å‰²å¤±è´¥: ${error.message}`
                });
              }
            }
          }
          
          updateProgress(parsedEntries.length, parsedEntries.length, "é‡æ„å®Œæˆ");
          restructuredEntries = newEntries;
          
          // æ˜¾ç¤ºé‡æ„ç»“æœ
          renderRestructureResult(newEntries);
          restructureDialog.showModal();
          renderStatus(`æ–‡ç« ç»“æ„é‡æ„å®Œæˆï¼šåŸ ${parsedEntries.length} ç«  â†’ æ–° ${newEntries.length} ç« `, "success");
        } catch (error) {
          console.error(error);
          renderStatus(`é‡æ„å¤±è´¥: ${error.message}`, "error");
        } finally {
          hideProgress();
          restructureButton.disabled = false;
        }
      });
      
      // æ¸²æŸ“é‡æ„ç»“æœ
      function renderRestructureResult(entries) {
        // æ¸²æŸ“ç›®å½•
        let tocHtml = `<div style="font-size: 13px; line-height: 2;">`;
        entries.forEach((entry, index) => {
          const isSplit = entry.split;
          const splitMarker = isSplit ? ` <span style="color: #8b5cf6; font-size: 11px;">[åˆ†å‰²]</span>` : "";
          const wordCountText = entry.word_count ? ` <span style="color: #64748b; font-size: 11px;">(${entry.word_count.toLocaleString()}å­—)</span>` : "";
          
          tocHtml += `<div style="padding: 8px 12px; margin: 4px 0; border-radius: 6px; cursor: pointer; transition: all 0.2s; border-left: 3px solid ${isSplit ? '#8b5cf6' : '#cbd5e1'};" 
                          onmouseover="this.style.background='#f1f5f9'" 
                          onmouseout="this.style.background='transparent'"
                          onclick="selectRestructureChapter(${index})">
                          <strong style="color: #1e293b;">${index + 1}. ${entry.title}</strong>${splitMarker}${wordCountText}
                          ${entry.warning ? `<div style="color: #ef4444; font-size: 11px; margin-top: 4px;">âš ï¸ ${entry.warning}</div>` : ""}
                        </div>`;
        });
        tocHtml += `</div>`;
        restructuredToc.innerHTML = tocHtml;
        
        // é»˜è®¤æ˜¾ç¤ºç¬¬ä¸€ä¸ªç« èŠ‚
        if (entries.length > 0) {
          selectRestructureChapter(0);
        }
      }
      
      // é€‰æ‹©ç« èŠ‚æ˜¾ç¤ºå†…å®¹ï¼ˆéœ€è¦åœ¨å…¨å±€ä½œç”¨åŸŸå®šä¹‰ï¼‰
      window.selectRestructureChapter = function(index) {
        if (index < 0 || index >= restructuredEntries.length) return;
        
        selectedRestructureIndex = index;
        const entry = restructuredEntries[index];
        
        // é«˜äº®é€‰ä¸­çš„ç›®å½•é¡¹
        restructuredToc.querySelectorAll("div[onclick]").forEach((div, i) => {
          if (i === index) {
            div.style.background = "#e0e7ff";
            div.style.borderLeftColor = "#6366f1";
          } else {
            div.style.background = "transparent";
            div.style.borderLeftColor = restructuredEntries[i].split ? "#8b5cf6" : "#cbd5e1";
          }
        });
        
        // æ˜¾ç¤ºå†…å®¹
        let contentHtml = `<div style="margin-bottom: 16px; padding: 12px; background: #f8fafc; border-radius: 8px; border-left: 4px solid #6366f1;">`;
        contentHtml += `<div style="font-weight: 600; font-size: 16px; color: #1e293b; margin-bottom: 8px;">${entry.title}</div>`;
        contentHtml += `<div style="font-size: 12px; color: #64748b;">`;
        if (entry.split) {
          contentHtml += `åŸç¬¬ ${entry.original_index + 1} ç« ï¼Œåˆ†å‰²åç¬¬ ${entry.segment_index + 1}/${entry.total_segments} éƒ¨åˆ† | `;
        } else {
          contentHtml += `åŸç¬¬ ${entry.original_index + 1} ç«  | `;
        }
        contentHtml += `å­—æ•°: ${(entry.word_count || 0).toLocaleString()} å­—`;
        contentHtml += `</div></div>`;
        
        contentHtml += `<div style="line-height: 1.8; color: #334155;">${(entry.content || "").replace(/\n/g, "<br>")}</div>`;
        
        restructuredContent.innerHTML = contentHtml;
        restructuredContent.scrollTop = 0;
      };

      ingestButton.addEventListener("click", async () => {
        if (!parsedEntries.length) {
          renderStatus("è¯·å…ˆå®Œæˆ PDF è§£æã€‚", "error");
          return;
        }

        ingestButton.disabled = true;
        renderStatus("æ­£åœ¨ç”Ÿæˆç« èŠ‚æ¦‚è¿°å¹¶å…¥åº“ï¼Œè¯·ç¨å€™...", "info");

        const totalChapters = parsedEntries.length;
        showProgress(totalChapters, "æ­£åœ¨å‡†å¤‡å…¥åº“ä»»åŠ¡...");

        try {
          const totalWordCount = parsedEntries.reduce((sum, entry) => {
            const wordCount = Number(entry.word_count);
            if (!Number.isNaN(wordCount) && wordCount > 0) {
              return sum + wordCount;
            }
            const content = entry.content || "";
            return sum + content.replace(/\s+/g, "").length;
          }, 0);

          const startResp = await fetch("/api/parse/ingest/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              filename: currentFilename,
              chapter_count: totalChapters,
              total_word_count: totalWordCount,
            }),
          });

          const startRaw = await startResp.text();
          const startTrimmed = startRaw.trim();
          let startPayload = {};
          if (startTrimmed) {
            try {
              startPayload = JSON.parse(startTrimmed);
            } catch (jsonError) {
              throw new Error(`å…¥åº“åˆå§‹åŒ–å“åº”æ ¼å¼é”™è¯¯: ${startTrimmed.substring(0, 200)}`);
            }
          }

          if (!startResp.ok) {
            throw new Error(startPayload.error || `å…¥åº“åˆå§‹åŒ–å¤±è´¥ (çŠ¶æ€ç : ${startResp.status})`);
          }

          const bookId = startPayload.book_id;
          if (bookId === undefined || bookId === null) {
            throw new Error("å…¥åº“åˆå§‹åŒ–å¤±è´¥ï¼šæœªè¿”å› book_id");
          }

          for (let index = 0; index < totalChapters; index++) {
            const entry = parsedEntries[index];
            const displayTitle = entry.title_zh || entry.title || `ç¬¬ ${index + 1} ç« `;
            updateProgress(index, totalChapters, `æ­£åœ¨å¤„ç†ç¬¬ ${index + 1}/${totalChapters} ç« ï¼š${displayTitle}`);

            const chapterResp = await fetch("/api/parse/ingest/chapter", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                book_id: bookId,
                entry,
                index,
              }),
            });

            const chapterRaw = await chapterResp.text();
            const chapterTrimmed = chapterRaw.trim();
            let chapterPayload = {};
            if (chapterTrimmed) {
              try {
                chapterPayload = JSON.parse(chapterTrimmed);
              } catch (jsonError) {
                throw new Error(`ç¬¬ ${index + 1} ç« å“åº”æ ¼å¼é”™è¯¯: ${chapterTrimmed.substring(0, 200)}`);
              }
            }

            if (!chapterResp.ok) {
              throw new Error(chapterPayload.error || `ç« èŠ‚ ${index + 1} å…¥åº“å¤±è´¥ (çŠ¶æ€ç : ${chapterResp.status})`);
            }

            const processedEntry = chapterPayload.entry || entry;
            parsedEntries[index] = processedEntry;
            updateProgress(index + 1, totalChapters, `å®Œæˆç¬¬ ${index + 1}/${totalChapters} ç« ï¼š${processedEntry.title_zh || processedEntry.title}`);
          }

          updateProgress(totalChapters, totalChapters, "æ‰€æœ‰ç« èŠ‚å¤„ç†å®Œæˆ");
          renderTable(parsedEntries);
          renderStatus("ç« èŠ‚æ¦‚è¿°å·²å®Œæˆå…¥åº“ã€‚", "success");
        } catch (error) {
          console.error(error);
          renderStatus(error.message || "æ¦‚è¿°å…¥åº“å¤±è´¥", "error");
        } finally {
          hideProgress();
          if (parsedEntries.length) {
            ingestButton.disabled = false;
          }
        }
      });

      // è‡ªåŠ¨é«˜äº®å½“å‰é¡µé¢çš„å¯¼èˆªé“¾æ¥
      function highlightCurrentNav() {
        const currentPath = window.location.pathname;
        document.querySelectorAll('.nav-link').forEach(link => {
          const href = link.getAttribute('href');
          if (href === currentPath || 
              (currentPath === '/' && href === '/') ||
              (currentPath !== '/' && currentPath.endsWith(href)) ||
              (href !== '/' && currentPath.includes(href.replace('/', '')))) {
            link.classList.add('active');
          } else {
            link.classList.remove('active');
          }
        });
      }

      // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨é«˜äº®å½“å‰é¡µé¢
      
      /**
       * ç”Ÿæˆç›®å½•ä¸æ‘˜è¦æ–‡æœ¬
       * 
       * è¾“å…¥ï¼šç« èŠ‚æ•°ç»„
       * è¾“å‡ºï¼šæ ¼å¼åŒ–çš„æ–‡æœ¬å­—ç¬¦ä¸²ï¼ˆç« èŠ‚åºå·+ç« èŠ‚æ ‡é¢˜+æ‘˜è¦ï¼‰
       * 
       * @param {Array} entries - ç« èŠ‚æ•°ç»„ï¼Œæ¯ä¸ªç« èŠ‚å¯¹è±¡åŒ…å« title_zh, title, summary ç­‰å­—æ®µ
       * @returns {string} ç”Ÿæˆçš„ç›®å½•ä¸æ‘˜è¦æ–‡æœ¬
       * 
       * @example
       * const entries = [
       *   { title_zh: "ç¬¬ä¸€ç« ", title: "Chapter 1", summary: "è¿™æ˜¯ç¬¬ä¸€ç« çš„æ‘˜è¦" },
       *   { title_zh: "ç¬¬äºŒç« ", title: "Chapter 2", summary: "è¿™æ˜¯ç¬¬äºŒç« çš„æ‘˜è¦" }
       * ];
       * const text = generateTocSummaryText(entries);
       * // è¾“å‡ºï¼š
       * // 1. ç¬¬ä¸€ç« 
       * // è¿™æ˜¯ç¬¬ä¸€ç« çš„æ‘˜è¦
       * //
       * // 2. ç¬¬äºŒç« 
       * // è¿™æ˜¯ç¬¬äºŒç« çš„æ‘˜è¦
       */
      function generateTocSummaryText(entries) {
        if (!entries || entries.length === 0) {
          return "";
        }

        let text = "";
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          const chapterNumber = i + 1;
          const chapterTitle = entry.title_zh || entry.title || `ç¬¬${chapterNumber}ç« `;
          const chapterSummary = entry.summary || "";

          // æ ¼å¼ï¼šç« èŠ‚åºå·+ç« èŠ‚æ ‡é¢˜+æ‘˜è¦
          text += `${chapterNumber}. ${chapterTitle}`;
          if (chapterSummary) {
            text += `\n${chapterSummary}`;
          }
          text += "\n\n";
        }

        return text.trim();
      }

      // ç›®å½•ä¸æ‘˜è¦è¯»å–åŠŸèƒ½
      const tocSummaryButton = document.getElementById("tocSummaryButton");
      const tocSummaryResult = document.getElementById("tocSummaryResult");
      const tocSummaryText = document.getElementById("tocSummaryText");
      const copyTocSummaryButton = document.getElementById("copyTocSummaryButton");

      if (tocSummaryButton) {
        tocSummaryButton.addEventListener("click", async () => {
          if (!parsedEntries || parsedEntries.length === 0) {
            renderStatus("è¯·å…ˆå®Œæˆè§£æ", "error");
            return;
          }

          tocSummaryButton.disabled = true;
          tocSummaryButton.textContent = "è¯»å–ä¸­...";
          if (tocSummaryResult) {
            tocSummaryResult.style.display = "none";
          }

          try {
            // è°ƒç”¨å‡½æ•°ç”Ÿæˆç›®å½•ä¸æ‘˜è¦æ–‡æœ¬
            const text = generateTocSummaryText(parsedEntries);

            // æ˜¾ç¤ºç»“æœ
            if (tocSummaryText) {
              tocSummaryText.value = text;
            }
            if (tocSummaryResult) {
              tocSummaryResult.style.display = "block";
            }
            renderStatus(`æˆåŠŸè¯»å– ${parsedEntries.length} ä¸ªç« èŠ‚çš„ç›®å½•ä¸æ‘˜è¦`, "success");
          } catch (error) {
            console.error("è¯»å–ç›®å½•ä¸æ‘˜è¦å¤±è´¥:", error);
            renderStatus(`è¯»å–å¤±è´¥: ${error.message}`, "error");
          } finally {
            tocSummaryButton.disabled = false;
            tocSummaryButton.textContent = "ğŸ“‹ ç›®å½•ä¸æ‘˜è¦è¯»å–";
          }
        });
      }

      // å¤åˆ¶ç›®å½•ä¸æ‘˜è¦æ–‡æœ¬
      if (copyTocSummaryButton) {
        copyTocSummaryButton.addEventListener("click", () => {
          if (tocSummaryText && tocSummaryText.value) {
            tocSummaryText.select();
            document.execCommand("copy");
            renderStatus("å·²å¤åˆ¶åˆ°å‰ªè´´æ¿", "success");
            
            // æ˜¾ç¤ºä¸´æ—¶æç¤º
            const originalText = copyTocSummaryButton.textContent;
            copyTocSummaryButton.textContent = "âœ“ å·²å¤åˆ¶";
            setTimeout(() => {
              copyTocSummaryButton.textContent = originalText;
            }, 2000);
          }
        });
      }

      document.addEventListener('DOMContentLoaded', () => {
        highlightCurrentNav();
      });
    </script>
  </body>
</html>

