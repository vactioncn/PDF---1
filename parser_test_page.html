<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>PDF è‡ªåŠ¨åŒ–è§£ææµ‹è¯•å°</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      :root {
        color-scheme: light;
        font-family: "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
        background-color: #f8fafc;
        color: #0f172a;
      }

      body {
        margin: 0;
        padding: 24px;
        max-width: 1400px;
        margin: 0 auto;
      }

      h1 {
        margin-top: 0;
        margin-bottom: 8px;
        font-size: 32px;
        font-weight: 600;
        color: #0f172a;
      }

      .subtitle {
        color: #64748b;
        font-size: 14px;
        margin-bottom: 32px;
      }

      .panel {
        background: #ffffff;
        border-radius: 16px;
        padding: 28px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        margin-bottom: 24px;
        border: 1px solid #e2e8f0;
      }

      .panel h2 {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 20px;
        font-weight: 600;
        color: #1e293b;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: flex-start;
      }

      .control-group {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        flex: 1;
        min-width: 300px;
      }

      .control-group.primary {
        flex: 2;
        min-width: 400px;
      }

      input[type="file"] {
        flex: 1;
        min-width: 200px;
        padding: 10px 14px;
        border: 1.5px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
        background: #ffffff;
        transition: border-color 0.2s, box-shadow 0.2s;
      }

      input[type="file"]:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      input[type="password"],
      input[type="text"] {
        flex: 1;
        min-width: 180px;
        padding: 10px 14px;
        border: 1.5px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
        background: #ffffff;
        transition: border-color 0.2s, box-shadow 0.2s;
      }

      input[type="password"]:focus,
      input[type="text"]:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      button {
        padding: 10px 20px;
        border-radius: 8px;
        border: none;
        background: #2563eb;
        color: white;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      button.secondary {
        background: #10b981;
      }

      button:disabled {
        background: #cbd5e1;
        color: #94a3b8;
        cursor: not-allowed;
        transform: none;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
      }

      button.secondary:hover:not(:disabled) {
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
      }

      button:active:not(:disabled) {
        transform: translateY(0);
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        border-radius: 12px;
        overflow: hidden;
        background: #ffffff;
      }

      thead {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      th {
        padding: 16px;
        text-align: left;
        font-weight: 600;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      td {
        padding: 16px;
        text-align: left;
        border-bottom: 1px solid #e2e8f0;
        vertical-align: top;
        font-size: 14px;
      }

      tbody tr {
        transition: background-color 0.15s ease;
      }

      tbody tr:hover {
        background: rgba(102, 126, 234, 0.05);
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      .status {
        margin-top: 16px;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        background: #f1f5f9;
        border-left: 4px solid #cbd5e1;
      }

      .status.info {
        background: #eff6ff;
        border-left-color: #3b82f6;
        color: #1e40af;
      }

      .status.success {
        background: #f0fdf4;
        border-left-color: #10b981;
        color: #065f46;
      }

      .status.error {
        background: #fef2f2;
        border-left-color: #ef4444;
        color: #991b1b;
      }

      .progress-wrapper {
        margin-bottom: 20px;
        display: none;
      }

      .progress-wrapper.active {
        display: block;
      }

      .progress-label {
        font-size: 14px;
        color: #475569;
        margin-bottom: 8px;
        font-weight: 500;
      }

      .progress-bar {
        width: 100%;
        height: 10px;
        border-radius: 999px;
        background: #e2e8f0;
        overflow: hidden;
        position: relative;
      }

      .progress-fill {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 0%;
        border-radius: 999px;
        background: linear-gradient(135deg, #4f46e5 0%, #14b8a6 100%);
        transition: width 0.3s ease;
      }

      .loading {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid rgba(0, 0, 0, 0.1);
        border-top-color: currentColor;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        margin-right: 8px;
        vertical-align: middle;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      @media (max-width: 768px) {
        body {
          padding: 16px;
        }

        .panel {
          padding: 20px;
        }

        .control-group {
          min-width: 100%;
        }

        .control-group.primary {
          min-width: 100%;
        }

        table {
          font-size: 12px;
        }

        th,
        td {
          padding: 12px 8px;
        }

        button {
          font-size: 13px;
          padding: 8px 16px;
        }
      }

      dialog {
        border: none;
        border-radius: 16px;
        padding: 0;
        width: min(800px, 90vw);
        max-height: 85vh;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      }

      dialog h3 {
        margin: 0;
        padding: 24px 28px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        font-size: 20px;
        font-weight: 600;
        border-radius: 16px 16px 0 0;
      }

      dialog .modal-body {
        padding: 24px 28px;
        overflow-y: auto;
        max-height: calc(85vh - 140px);
        white-space: pre-wrap;
        line-height: 1.8;
        color: #334155;
        font-size: 14px;
      }

      dialog > div:last-child {
        padding: 20px 28px;
        background: #f8fafc;
        border-radius: 0 0 16px 16px;
        border-top: 1px solid #e2e8f0;
      }

      dialog::backdrop {
        background-color: rgba(15, 23, 42, 0.5);
        backdrop-filter: blur(4px);
      }
    </style>
  </head>
  <body>
    <h1>æ–‡æ¡£è‡ªåŠ¨åŒ–è§£ææµ‹è¯•å°</h1>
    <p class="subtitle">ä¸Šä¼  PDF æˆ– EPUB æ–‡ä»¶ï¼Œè‡ªåŠ¨æå–ç›®å½•ç« èŠ‚å¹¶ç”Ÿæˆæ¦‚è¿°</p>

    <section class="panel">
      <h2>ğŸ“„ æ–‡ä»¶ä¸Šä¼ ä¸è§£æ</h2>
      <div class="controls">
        <div class="control-group primary">
          <input type="file" id="pdfFile" accept="application/pdf,application/epub+zip,.pdf,.epub" />
          <button id="cleanTocButton">æ­¥éª¤1: ç›®å½•æ¸…æ´—</button>
          <button id="extractButton" disabled>æ­¥éª¤2: è§£æå†…å®¹ä¸ç»Ÿè®¡</button>
          <button id="testTranslateButton" style="background: #10b981; color: white;">ğŸŒ æµ‹è¯•ç¿»è¯‘</button>
        </div>
      </div>
      <div class="status" id="statusArea"></div>
    </section>

    <section class="panel">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 12px;">
        <h2 style="margin: 0;">ğŸ“Š è§£æç»“æœ</h2>
        <button id="ingestButton" class="secondary" disabled style="font-size: 15px; padding: 12px 24px;">
          ğŸ“ åŸºæœ¬ä¿¡æ¯å…¥åº“
        </button>
      </div>
      <div id="progressWrapper" class="progress-wrapper">
        <div id="progressLabel" class="progress-label">å‡†å¤‡ä¸­...</div>
        <div class="progress-bar">
          <div id="progressFill" class="progress-fill"></div>
        </div>
      </div>
      <table>
        <thead>
          <tr>
            <th>ç›®å½•æ ‡é¢˜</th>
            <th>æŠ½å–å†…å®¹</th>
            <th>ç»Ÿè®¡å­—æ•°</th>
            <th>ç¿»è¯‘</th>
            <th>ç« èŠ‚æ¦‚è¿°</th>
          </tr>
        </thead>
        <tbody id="resultsBody">
          <tr>
            <td colspan="5" style="text-align: center; color: #94a3b8; padding: 40px;">
              ç­‰å¾…è§£æç»“æœ...
            </td>
          </tr>
        </tbody>
      </table>
    </section>

    <dialog id="contentDialog">
      <h3 id="dialogTitle"></h3>
      <div class="modal-body" id="dialogContent"></div>
      <div style="text-align: right">
        <button id="closeDialog">å…³é—­</button>
      </div>
    </dialog>

    <dialog id="tocCompareDialog" style="max-width: 90vw; width: 1200px; padding: 0; border-radius: 12px;">
      <div style="padding: 24px; border-bottom: 1px solid #e2e8f0;">
        <h3 style="margin: 0; font-size: 20px; font-weight: 600;">ç›®å½•æ¸…æ´—å¯¹æ¯”</h3>
      </div>
      <div style="padding: 24px; display: grid; grid-template-columns: 1fr 1fr; gap: 24px; max-height: 70vh; overflow-y: auto;">
        <div>
          <h4 style="margin: 0 0 16px 0; color: #64748b; font-size: 14px; font-weight: 600;">æ¸…æ´—å‰ (å…± <span id="rawCount">0</span> é¡¹)</h4>
          <div id="rawTocList" style="background: #f8fafc; padding: 16px; border-radius: 8px; font-size: 13px; line-height: 1.8; max-height: 60vh; overflow-y: auto;"></div>
        </div>
        <div>
          <h4 style="margin: 0 0 16px 0; color: #10b981; font-size: 14px; font-weight: 600;">æ¸…æ´—å (å…± <span id="cleanedCount">0</span> é¡¹)</h4>
          <div id="cleanedTocList" style="background: #f0fdf4; padding: 16px; border-radius: 8px; font-size: 13px; line-height: 1.8; max-height: 60vh; overflow-y: auto;"></div>
        </div>
      </div>
      <div style="padding: 16px 24px; border-top: 1px solid #e2e8f0; text-align: right;">
        <button id="closeTocDialog" style="padding: 10px 20px; border-radius: 8px; border: none; background: #2563eb; color: white; cursor: pointer;">å…³é—­</button>
      </div>
    </dialog>

    <dialog id="translateTestDialog" style="max-width: 90vw; width: 800px; padding: 0; border-radius: 12px;">
      <div style="padding: 24px; border-bottom: 1px solid #e2e8f0;">
        <h3 style="margin: 0; font-size: 20px; font-weight: 600;">ğŸŒ ç¿»è¯‘æµ‹è¯•</h3>
      </div>
      <div style="padding: 24px; max-height: 80vh; overflow-y: auto;">
        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 600;">è¾“å…¥è¦ç¿»è¯‘çš„æ–‡æœ¬ï¼ˆéä¸­æ–‡ï¼‰ï¼š</label>
          <textarea id="translateInput" style="width: 100%; min-height: 100px; padding: 12px; border: 1.5px solid #cbd5e1; border-radius: 8px; font-size: 14px; font-family: inherit;" placeholder="è¾“å…¥è‹±æ–‡æˆ–å…¶ä»–è¯­è¨€çš„æ–‡æœ¬..."></textarea>
        </div>
        <div>
          <label style="display: block; margin-bottom: 8px; font-weight: 600;">ç¿»è¯‘ç»“æœï¼ˆä¸­æ–‡ï¼‰ï¼š</label>
          <div id="translateOutput" style="width: 100%; min-height: 100px; padding: 12px; border: 1.5px solid #cbd5e1; border-radius: 8px; font-size: 14px; background: #f8fafc; white-space: pre-wrap; word-wrap: break-word;"></div>
        </div>
      </div>
      <div style="padding: 16px 24px; border-top: 1px solid #e2e8f0; display: flex; justify-content: space-between;">
        <button id="doTranslateButton" style="padding: 10px 20px; border-radius: 8px; border: none; background: #10b981; color: white; cursor: pointer;">ç¿»è¯‘</button>
        <button id="closeTranslateDialog" style="padding: 10px 20px; border-radius: 8px; border: none; background: #2563eb; color: white; cursor: pointer;">å…³é—­</button>
      </div>
    </dialog>

    <script>
      const cleanTocButton = document.getElementById("cleanTocButton");
      const extractButton = document.getElementById("extractButton");
      const testTranslateButton = document.getElementById("testTranslateButton");
      const pdfFile = document.getElementById("pdfFile");
      const ingestButton = document.getElementById("ingestButton");
      const statusArea = document.getElementById("statusArea");
      const resultsBody = document.getElementById("resultsBody");
      const dialog = document.getElementById("contentDialog");
      const dialogTitle = document.getElementById("dialogTitle");
      const dialogContent = document.getElementById("dialogContent");
      const closeDialog = document.getElementById("closeDialog");
      const tocCompareDialog = document.getElementById("tocCompareDialog");
      const closeTocDialog = document.getElementById("closeTocDialog");
      const translateTestDialog = document.getElementById("translateTestDialog");
      const closeTranslateDialog = document.getElementById("closeTranslateDialog");
      const doTranslateButton = document.getElementById("doTranslateButton");
      const translateInput = document.getElementById("translateInput");
      const translateOutput = document.getElementById("translateOutput");
      const rawTocList = document.getElementById("rawTocList");
      const cleanedTocList = document.getElementById("cleanedTocList");
      const rawCount = document.getElementById("rawCount");
      const cleanedCount = document.getElementById("cleanedCount");
      const progressWrapper = document.getElementById("progressWrapper");
      const progressLabel = document.getElementById("progressLabel");
      const progressFill = document.getElementById("progressFill");
      let parsedEntries = [];
      let currentFilename = "";
      let cleanedTocData = null;
      let currentFileType = null;

      closeDialog.addEventListener("click", () => dialog.close());
      closeTocDialog.addEventListener("click", () => tocCompareDialog.close());
      closeTranslateDialog.addEventListener("click", () => translateTestDialog.close());

      function renderTocCompare(rawToc, cleanedToc) {
        rawCount.textContent = rawToc.length;
        cleanedCount.textContent = cleanedToc.length;

        rawTocList.innerHTML = "";
        rawToc.forEach((item) => {
          const div = document.createElement("div");
          div.style.paddingLeft = `${(item.level - 1) * 20}px`;
          div.style.marginBottom = "4px";
          div.textContent = `${item.title} (ç¬¬${item.page}é¡µ)`;
          rawTocList.appendChild(div);
        });

        cleanedTocList.innerHTML = "";
        cleanedToc.forEach((item) => {
          const div = document.createElement("div");
          div.style.paddingLeft = `${(item.level - 1) * 20}px`;
          div.style.marginBottom = "4px";
          div.textContent = `${item.title} (ç¬¬${item.page}é¡µ)`;
          cleanedTocList.appendChild(div);
        });

        tocCompareDialog.showModal();
      }

      function renderStatus(message, type = "info") {
        statusArea.className = `status ${type}`;
        const loading = type === "info" && (message.includes("æ­£åœ¨") || message.includes("è¯·ç¨å€™")) 
          ? '<span class="loading"></span>' 
          : '';
        statusArea.innerHTML = loading + message;
      }

      function showProgress(total = 0, label = "æ­£åœ¨å‡†å¤‡å…¥åº“...") {
        if (!progressWrapper) return;
        progressWrapper.classList.add("active");
        updateProgress(0, total, label);
      }

      function updateProgress(completed, total, label) {
        if (!progressWrapper) return;
        if (!progressWrapper.classList.contains("active")) {
          progressWrapper.classList.add("active");
        }
        if (progressWrapper.style.display !== "block") {
          progressWrapper.style.display = "block";
        }
        const percent = total > 0 ? Math.min(100, Math.max(0, Math.round((completed / total) * 100))) : 0;
        if (progressFill) {
          progressFill.style.width = `${percent}%`;
        }
        if (progressLabel) {
          progressLabel.textContent = label || `è¿›åº¦ï¼š${completed}/${total} (${percent}%)`;
        }
      }

      function hideProgress() {
        if (!progressWrapper) return;
        progressWrapper.classList.remove("active");
        progressWrapper.style.display = "none";
        if (progressFill) {
          progressFill.style.width = "0%";
        }
      }

      function renderTable(entries) {
        if (!entries || entries.length === 0) {
          resultsBody.innerHTML = `<tr><td colspan="5" style="text-align: center; color: #94a3b8; padding: 40px;">æœªè¯†åˆ«åˆ°æœ‰æ•ˆç›®å½•ã€‚</td></tr>`;
          ingestButton.disabled = true;
          return;
        }

        resultsBody.innerHTML = "";
        ingestButton.disabled = false;
        for (let index = 0; index < entries.length; index++) {
          const entry = entries[index];
          const row = document.createElement("tr");

          // ä½¿ç”¨ä¸­æ–‡æ ‡é¢˜ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨åŸæ–‡
          const titleCell = document.createElement("td");
          const displayTitle = entry.title_zh || entry.title;
          titleCell.textContent = displayTitle;
          // å¦‚æœåŸæ–‡å’Œä¸­æ–‡ä¸åŒï¼Œæ˜¾ç¤ºæç¤º
          if (entry.title_zh && entry.title_zh !== entry.title) {
            titleCell.title = `åŸæ–‡: ${entry.title}`;
            titleCell.style.color = "#2563eb";
          }

          const contentCell = document.createElement("td");
          const viewButton = document.createElement("button");
          viewButton.textContent = "æŸ¥çœ‹å®Œæ•´å†…å®¹";
          viewButton.style.fontSize = "13px";
          viewButton.style.padding = "6px 12px";
          viewButton.addEventListener("click", () => {
            // æ˜¾ç¤ºä¸­æ–‡å†…å®¹ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ˜¾ç¤ºåŸæ–‡
            const displayContent = entry.content_zh || entry.content || "(æš‚æ— æ­£æ–‡å†…å®¹)";
            dialogTitle.textContent = displayTitle;
            dialogContent.textContent = displayContent;
            // å¦‚æœåŸæ–‡å’Œä¸­æ–‡ä¸åŒï¼Œåœ¨æ ‡é¢˜ä¸­æ˜¾ç¤ºæç¤º
            if (entry.content_zh && entry.content_zh !== entry.content) {
              dialogTitle.textContent = `${displayTitle} (å·²ç¿»è¯‘)`;
            }
            dialog.showModal();
          });
          contentCell.appendChild(viewButton);

          const countCell = document.createElement("td");
          const count = entry.word_count || 0;
          countCell.innerHTML = `<span style="font-weight: 500; color: #475569;">${count.toLocaleString()}</span> <span style="color: #94a3b8; font-size: 12px;">å­—</span>`;

          // ç¿»è¯‘æŒ‰é’®åˆ—
          const translateCell = document.createElement("td");
          // åˆ¤æ–­æ˜¯å¦å·²ç¿»è¯‘ï¼šæ ‡é¢˜å’Œå†…å®¹éƒ½å¿…é¡»æœ‰ç¿»è¯‘ï¼Œä¸”éƒ½ä¸åŸæ–‡ä¸åŒ
          const hasTranslation = entry.title_zh && entry.content_zh && 
                                 entry.title_zh !== entry.title && entry.content_zh !== entry.content;
          const isChinese = entry.title && /[\u4e00-\u9fff]/.test(entry.title);
          
          if (hasTranslation) {
            // å·²æœ‰ç¿»è¯‘ï¼Œæ˜¾ç¤ºçŠ¶æ€
            translateCell.innerHTML = '<span style="color: #10b981; font-size: 12px;">âœ“ å·²ç¿»è¯‘</span>';
          } else if (!isChinese && entry.title) {
            // éä¸­æ–‡ï¼Œæ˜¾ç¤ºç¿»è¯‘æŒ‰é’®
            const translateButton = document.createElement("button");
            translateButton.textContent = "ğŸŒ ç¿»è¯‘";
            translateButton.style.fontSize = "13px";
            translateButton.style.padding = "6px 12px";
            translateButton.style.background = "#10b981";
            translateButton.style.color = "white";
            translateButton.style.border = "none";
            translateButton.style.borderRadius = "6px";
            translateButton.style.cursor = "pointer";
            translateButton.addEventListener("click", async () => {
              translateButton.disabled = true;
              translateButton.textContent = "ç¿»è¯‘ä¸­...";
              renderStatus(`æ­£åœ¨ç¿»è¯‘ç« èŠ‚: ${entry.title}...`, "info");
              
              try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 600000); // 10åˆ†é’Ÿè¶…æ—¶ï¼Œæ”¯æŒé•¿æ–‡æœ¬ç¿»è¯‘
                
                let response;
                try {
                  response = await fetch("/api/translate/chapter", {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                      title: entry.title,
                      content: entry.content || "",
                    }),
                    signal: controller.signal,
                  });
                } catch (fetchError) {
                  clearTimeout(timeoutId);
                  if (fetchError.name === "AbortError") {
                    throw new Error("ç¿»è¯‘è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•æˆ–åˆ†æ®µç¿»è¯‘");
                  }
                  throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${fetchError.message}`);
                }
                clearTimeout(timeoutId);

                if (!response.ok) {
                  const payload = await response.json();
                  throw new Error(payload.error || `ç¿»è¯‘å¤±è´¥ (çŠ¶æ€ç : ${response.status})`);
                }

                const payload = await response.json();
                // æ›´æ–°entryæ•°æ®ï¼ˆentryæ˜¯parsedEntriesä¸­çš„å¼•ç”¨ï¼Œä¼šè‡ªåŠ¨åŒæ­¥ï¼‰
                entry.title_zh = payload.title_zh || entry.title_zh;
                entry.content_zh = payload.content_zh || entry.content_zh;
                // å¦‚æœç¿»è¯‘åç”Ÿæˆäº†æ¦‚è¦ï¼Œä¹Ÿæ›´æ–°æ¦‚è¦
                if (payload.summary) {
                  entry.summary = payload.summary;
                }
                
                // é‡æ–°æ¸²æŸ“è¡¨æ ¼ä»¥æ›´æ–°æ˜¾ç¤ºï¼ˆä½¿ç”¨å…¨å±€parsedEntriesï¼‰
                renderTable(parsedEntries);
                
                // æ˜¾ç¤ºç¿»è¯‘ç»“æœæ¶ˆæ¯
                const titleTranslated = payload.title_zh && payload.title_zh !== entry.title;
                const contentTranslated = payload.content_zh && payload.content_zh !== entry.content;
                
                if (payload.warning) {
                  // æœ‰è­¦å‘Šï¼ˆç¿»è¯‘å¤±è´¥ï¼‰
                  renderStatus(payload.warning, "warning");
                } else if (titleTranslated && contentTranslated) {
                  // ç¿»è¯‘æˆåŠŸ
                  const successMsg = payload.summary 
                    ? `ç« èŠ‚ç¿»è¯‘å®Œæˆå¹¶å·²ç”Ÿæˆæ¦‚è¦: ${payload.title_zh}`
                    : `ç« èŠ‚ç¿»è¯‘å®Œæˆ: ${payload.title_zh}`;
                  renderStatus(successMsg, "success");
                } else if (titleTranslated && !contentTranslated) {
                  // æ ‡é¢˜ç¿»è¯‘æˆåŠŸï¼Œä½†å†…å®¹ç¿»è¯‘å¤±è´¥
                  renderStatus(`æ ‡é¢˜ç¿»è¯‘å®Œæˆï¼Œä½†å†…å®¹ç¿»è¯‘å¤±è´¥: ${payload.title_zh}`, "warning");
                } else if (!titleTranslated && contentTranslated) {
                  // æ ‡é¢˜ç¿»è¯‘å¤±è´¥ï¼Œä½†å†…å®¹ç¿»è¯‘æˆåŠŸ
                  renderStatus(`å†…å®¹ç¿»è¯‘å®Œæˆï¼Œä½†æ ‡é¢˜ç¿»è¯‘å¤±è´¥`, "warning");
                } else {
                  // éƒ½ç¿»è¯‘å¤±è´¥
                  renderStatus(`ç¿»è¯‘å¤±è´¥: æ ‡é¢˜å’Œå†…å®¹éƒ½æœªèƒ½ç¿»è¯‘`, "error");
                }
              } catch (error) {
                console.error(error);
                translateButton.disabled = false;
                translateButton.textContent = "ğŸŒ ç¿»è¯‘";
                renderStatus(error.message, "error");
              }
            });
            translateCell.appendChild(translateButton);
          } else {
            // ä¸­æ–‡å†…å®¹ï¼Œä¸éœ€è¦ç¿»è¯‘
            translateCell.innerHTML = '<span style="color: #94a3b8; font-size: 12px;">â€”</span>';
          }

          const summaryCell = document.createElement("td");
          if (entry.summary) {
            const summaryButton = document.createElement("button");
            summaryButton.textContent = "æŸ¥çœ‹ç« èŠ‚æ¦‚è¿°";
            summaryButton.style.fontSize = "13px";
            summaryButton.style.padding = "6px 12px";
            summaryButton.addEventListener("click", () => {
              dialogTitle.textContent = `${displayTitle} - æ¦‚è¿°`;
              dialogContent.textContent = entry.summary || "(æš‚æ— æ¦‚è¿°)";
              dialog.showModal();
            });
            summaryCell.appendChild(summaryButton);
          } else {
            summaryCell.innerHTML = '<span style="color: #94a3b8;">â€”</span>';
          }

          row.appendChild(titleCell);
          row.appendChild(contentCell);
          row.appendChild(countCell);
          row.appendChild(translateCell);
          row.appendChild(summaryCell);
          resultsBody.appendChild(row);
        }
      }

      cleanTocButton.addEventListener("click", async () => {
        if (!pdfFile.files.length) {
          renderStatus("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ï¼ˆPDFæˆ–EPUBï¼‰ã€‚", "error");
          return;
        }

        const formData = new FormData();
        formData.append("file", pdfFile.files[0]);

        cleanTocButton.disabled = true;
        renderStatus("æ­£åœ¨æ¸…æ´—ç›®å½•ï¼Œè¯·ç¨å€™...", "info");

        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 300000);

          let response;
          try {
            response = await fetch("/api/parse/clean_toc", {
              method: "POST",
              body: formData,
              signal: controller.signal,
            });
          } catch (fetchError) {
            clearTimeout(timeoutId);
            if (fetchError.name === "AbortError") {
              throw new Error("è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•");
            }
            throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${fetchError.message}`);
          }
          clearTimeout(timeoutId);

          let payload;
          try {
            payload = await response.json();
          } catch (jsonError) {
            throw new Error(`æœåŠ¡å™¨å“åº”æ ¼å¼é”™è¯¯: ${jsonError.message}`);
          }

          if (!response.ok) {
            throw new Error(payload.error || `æ¸…æ´—ç›®å½•å¤±è´¥ (çŠ¶æ€ç : ${response.status})`);
          }

          cleanedTocData = payload.cleaned_toc || [];
          currentFilename = payload.filename || "æœªçŸ¥æ–‡ä»¶";
          currentFileType = payload.file_type || null;
          
          // è°ƒè¯•æ—¥å¿—
          console.log("æ­¥éª¤1å®Œæˆï¼šæ¸…æ´—åçš„ç›®å½•ï¼Œå…±", cleanedTocData.length, "ä¸ªæ¡ç›®");
          if (cleanedTocData.length > 0) {
            console.log("æ¸…æ´—åç›®å½•ç¤ºä¾‹ï¼š", cleanedTocData[0]);
          }
          
          renderStatus("ç›®å½•æ¸…æ´—å®Œæˆï¼Œè¯·æŸ¥çœ‹å¯¹æ¯”ç»“æœã€‚", "success");
          renderTocCompare(payload.raw_toc || [], payload.cleaned_toc || []);
          extractButton.disabled = false;
        } catch (error) {
          console.error(error);
          renderStatus(error.message, "error");
          cleanedTocData = null;
          extractButton.disabled = true;
        } finally {
          cleanTocButton.disabled = false;
        }
      });

      testTranslateButton.addEventListener("click", () => {
        translateTestDialog.showModal();
        translateInput.value = "";
        translateOutput.textContent = "";
      });

      doTranslateButton.addEventListener("click", async () => {
        const text = translateInput.value.trim();
        if (!text) {
          renderStatus("è¯·è¾“å…¥è¦ç¿»è¯‘çš„æ–‡æœ¬ã€‚", "error");
          return;
        }

        doTranslateButton.disabled = true;
        translateOutput.textContent = "æ­£åœ¨ç¿»è¯‘...";
        renderStatus("æ­£åœ¨ç¿»è¯‘æ–‡æœ¬...", "info");

        try {
          const response = await fetch("/api/translate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ text }),
          });

          if (!response.ok) {
            const payload = await response.json();
            throw new Error(payload.error || `ç¿»è¯‘å¤±è´¥ (çŠ¶æ€ç : ${response.status})`);
          }

          const payload = await response.json();
          translateOutput.textContent = payload.translated || payload.result || "ç¿»è¯‘å¤±è´¥";
          renderStatus("ç¿»è¯‘å®Œæˆã€‚", "success");
        } catch (error) {
          console.error(error);
          translateOutput.textContent = `ç¿»è¯‘å¤±è´¥: ${error.message}`;
          renderStatus(error.message, "error");
        } finally {
          doTranslateButton.disabled = false;
        }
      });

      extractButton.addEventListener("click", async () => {
        if (!pdfFile.files.length) {
          renderStatus("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ï¼ˆPDFæˆ–EPUBï¼‰ã€‚", "error");
          return;
        }

        if (!cleanedTocData || cleanedTocData.length === 0) {
          renderStatus("è¯·å…ˆå®Œæˆæ­¥éª¤1ï¼šç›®å½•æ¸…æ´—ã€‚", "error");
          return;
        }

        const formData = new FormData();
        formData.append("file", pdfFile.files[0]);

        extractButton.disabled = true;
        renderStatus("æ­£åœ¨æå–å†…å®¹å¹¶ç»Ÿè®¡ï¼Œè¯·ç¨å€™...", "info");
        renderTable([]);

        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 300000);

          // éªŒè¯æ¸…æ´—åçš„ç›®å½•æ•°æ®
          if (!cleanedTocData || cleanedTocData.length === 0) {
            renderStatus("é”™è¯¯ï¼šæ¸…æ´—åçš„ç›®å½•ä¸ºç©ºï¼Œè¯·é‡æ–°æ‰§è¡Œæ­¥éª¤1ã€‚", "error");
            return;
          }

          // è°ƒè¯•æ—¥å¿—
          console.log("æ­¥éª¤2ï¼šä½¿ç”¨æ¸…æ´—åçš„ç›®å½•ï¼Œå…±", cleanedTocData.length, "ä¸ªæ¡ç›®");
          console.log("æ¸…æ´—åç›®å½•ç¤ºä¾‹ï¼š", cleanedTocData[0]);

          // ä½¿ç”¨FormDataå‘é€æ–‡ä»¶å’ŒJSONæ•°æ®
          const formDataWithJson = new FormData();
          formDataWithJson.append("file", pdfFile.files[0]);
          formDataWithJson.append("cleaned_toc", JSON.stringify(cleanedTocData));
          if (currentFileType) {
            formDataWithJson.append("file_type", currentFileType);
          }

          let response;
          try {
            response = await fetch("/api/parse/extract", {
              method: "POST",
              body: formDataWithJson,
              signal: controller.signal,
            });
          } catch (fetchError) {
            clearTimeout(timeoutId);
            if (fetchError.name === "AbortError") {
              throw new Error("è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•");
            }
            throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${fetchError.message}`);
          }
          clearTimeout(timeoutId);

          let payload;
          try {
            payload = await response.json();
          } catch (jsonError) {
            throw new Error(`æœåŠ¡å™¨å“åº”æ ¼å¼é”™è¯¯: ${jsonError.message}`);
          }

          if (!response.ok) {
            throw new Error(payload.error || `æå–å†…å®¹å¤±è´¥ (çŠ¶æ€ç : ${response.status})`);
          }

          renderStatus("å†…å®¹æå–å®Œæˆï¼Œè¯·éªŒæ”¶ç»“æœã€‚", "success");
          parsedEntries = payload.entries || [];
          currentFilename = payload.filename || currentFilename;
          renderTable(parsedEntries);
          ingestButton.disabled = parsedEntries.length === 0;
        } catch (error) {
          console.error(error);
          renderStatus(error.message, "error");
          parsedEntries = [];
          renderTable([]);
        } finally {
          extractButton.disabled = false;
        }
      });

      ingestButton.addEventListener("click", async () => {
        if (!parsedEntries.length) {
          renderStatus("è¯·å…ˆå®Œæˆ PDF è§£æã€‚", "error");
          return;
        }

        ingestButton.disabled = true;
        renderStatus("æ­£åœ¨ç”Ÿæˆç« èŠ‚æ¦‚è¿°å¹¶å…¥åº“ï¼Œè¯·ç¨å€™...", "info");

        const totalChapters = parsedEntries.length;
        showProgress(totalChapters, "æ­£åœ¨å‡†å¤‡å…¥åº“ä»»åŠ¡...");

        try {
          const totalWordCount = parsedEntries.reduce((sum, entry) => {
            const wordCount = Number(entry.word_count);
            if (!Number.isNaN(wordCount) && wordCount > 0) {
              return sum + wordCount;
            }
            const content = entry.content || "";
            return sum + content.replace(/\s+/g, "").length;
          }, 0);

          const startResp = await fetch("/api/parse/ingest/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              filename: currentFilename,
              chapter_count: totalChapters,
              total_word_count: totalWordCount,
            }),
          });

          const startRaw = await startResp.text();
          const startTrimmed = startRaw.trim();
          let startPayload = {};
          if (startTrimmed) {
            try {
              startPayload = JSON.parse(startTrimmed);
            } catch (jsonError) {
              throw new Error(`å…¥åº“åˆå§‹åŒ–å“åº”æ ¼å¼é”™è¯¯: ${startTrimmed.substring(0, 200)}`);
            }
          }

          if (!startResp.ok) {
            throw new Error(startPayload.error || `å…¥åº“åˆå§‹åŒ–å¤±è´¥ (çŠ¶æ€ç : ${startResp.status})`);
          }

          const bookId = startPayload.book_id;
          if (bookId === undefined || bookId === null) {
            throw new Error("å…¥åº“åˆå§‹åŒ–å¤±è´¥ï¼šæœªè¿”å› book_id");
          }

          for (let index = 0; index < totalChapters; index++) {
            const entry = parsedEntries[index];
            const displayTitle = entry.title_zh || entry.title || `ç¬¬ ${index + 1} ç« `;
            updateProgress(index, totalChapters, `æ­£åœ¨å¤„ç†ç¬¬ ${index + 1}/${totalChapters} ç« ï¼š${displayTitle}`);

            const chapterResp = await fetch("/api/parse/ingest/chapter", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                book_id: bookId,
                entry,
                index,
              }),
            });

            const chapterRaw = await chapterResp.text();
            const chapterTrimmed = chapterRaw.trim();
            let chapterPayload = {};
            if (chapterTrimmed) {
              try {
                chapterPayload = JSON.parse(chapterTrimmed);
              } catch (jsonError) {
                throw new Error(`ç¬¬ ${index + 1} ç« å“åº”æ ¼å¼é”™è¯¯: ${chapterTrimmed.substring(0, 200)}`);
              }
            }

            if (!chapterResp.ok) {
              throw new Error(chapterPayload.error || `ç« èŠ‚ ${index + 1} å…¥åº“å¤±è´¥ (çŠ¶æ€ç : ${chapterResp.status})`);
            }

            const processedEntry = chapterPayload.entry || entry;
            parsedEntries[index] = processedEntry;
            updateProgress(index + 1, totalChapters, `å®Œæˆç¬¬ ${index + 1}/${totalChapters} ç« ï¼š${processedEntry.title_zh || processedEntry.title}`);
          }

          updateProgress(totalChapters, totalChapters, "æ‰€æœ‰ç« èŠ‚å¤„ç†å®Œæˆ");
          renderTable(parsedEntries);
          renderStatus("ç« èŠ‚æ¦‚è¿°å·²å®Œæˆå…¥åº“ã€‚", "success");
        } catch (error) {
          console.error(error);
          renderStatus(error.message || "æ¦‚è¿°å…¥åº“å¤±è´¥", "error");
        } finally {
          hideProgress();
          if (parsedEntries.length) {
            ingestButton.disabled = false;
          }
        }
      });
    </script>
  </body>
</html>

